{
  "metadata": {
    "generated_at": "2025-10-29T03:34:44.682373",
    "level": "NIVEL3",
    "purpose": "Comprehensive method execution aptitude analysis",
    "total_files": 8,
    "analyst": "Automated NIVEL3 Analysis System",
    "version": "3.0.0"
  },
  "summary": {
    "total_methods": 593,
    "by_complexity": {
      "LOW": 280,
      "MEDIUM": 282,
      "HIGH": 31
    },
    "by_priority": {
      "LOW": 289,
      "MEDIUM": 236,
      "HIGH": 24,
      "CRITICAL": 44
    },
    "average_aptitude_score": 98.45699831365935
  },
  "files": {
    "financiero_viabilidad_tablas.py": {
      "method_count": 61,
      "methods": [
        {
          "method_name": "__init__",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "__init__(self, use_gpu, language, confidence_threshold)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 281,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_get_spanish_stopwords",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_get_spanish_stopwords(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 322,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_clean_dataframe",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_clean_dataframe(self, df)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 402,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_is_likely_header",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_is_likely_header(self, row)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 420,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_deduplicate_tables",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_deduplicate_tables(self, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 428,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_tables",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_classify_tables(self, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 495,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "analyze_financial_feasibility",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "analyze_financial_feasibility(self, tables, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 521,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_financial_amounts",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_financial_amounts(self, text, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 538,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_funding_source",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_identify_funding_source(self, context)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 585,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_from_budget_table",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_from_budget_table(self, df)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 602,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_analyze_funding_sources",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_analyze_funding_sources(self, indicators, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 642,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_assess_financial_sustainability",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_assess_financial_sustainability(self, indicators, funding_sources)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 663,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_bayesian_risk_inference",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_bayesian_risk_inference(self, indicators, funding_sources, sustainability)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "numpy",
            "scipy",
            "statistical libraries"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 679,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_interpret_risk",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_interpret_risk(self, risk)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 721,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_indicator_to_dict",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_indicator_to_dict(self, ind)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 733,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "identify_responsible_entities",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "identify_responsible_entities(self, text, tables)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 747,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_entities_ner",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_entities_ner(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 761,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_entities_syntax",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_entities_syntax(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 786,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_entity_type",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_classify_entity_type(self, name)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 813,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_from_responsibility_tables",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_from_responsibility_tables(self, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 826,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_consolidate_entities",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_consolidate_entities(self, entities)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 857,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_entity_specificity",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_entity_specificity(self, entities, full_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 891,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "construct_causal_dag",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "construct_causal_dag(self, text, tables, financial_analysis)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 916,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 75.0
        },
        {
          "method_name": "_identify_causal_nodes",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_identify_causal_nodes(self, text, tables, financial_analysis)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 958,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_find_semantic_mentions",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_find_semantic_mentions(self, text, concept, concept_embedding)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1008,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_find_outcome_mentions",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_find_outcome_mentions(self, text, outcome)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1026,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_find_mediator_mentions",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_find_mediator_mentions(self, text, mediator)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1058,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_budget_for_pillar",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_budget_for_pillar(self, pillar, text, financial_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1089,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_causal_edges",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_identify_causal_edges(self, text, nodes)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 1110,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_match_text_to_node",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_match_text_to_node(self, text, nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1173,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_refine_edge_probabilities",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_refine_edge_probabilities(self, edges, text, nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1196,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_break_cycles",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_break_cycles(self, G)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1219,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "estimate_causal_effects",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "estimate_causal_effects(self, dag, text, financial_analysis)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 1234,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 75.0
        },
        {
          "method_name": "_estimate_effect_bayesian",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_estimate_effect_bayesian(self, treatment, outcome, dag, financial_analysis)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "numpy",
            "scipy",
            "statistical libraries"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "No documentation available",
          "line_number": 1259,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_get_prior_effect",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_get_prior_effect(self, treatment, outcome)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Priors informados basados en meta-análisis de programas PDET\nReferencia: Cinelli et al. (2022) - Sensitivity Analysis for Causal Inference",
          "line_number": 1329,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_confounders",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_identify_confounders(self, treatment, outcome, dag)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Identifica confounders usando d-separation (Pearl, 2009)",
          "line_number": 1349,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_counterfactuals",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "generate_counterfactuals(self, dag, causal_effects, financial_analysis)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Genera escenarios contrafactuales usando el framework de Pearl (2009)\nLevel 3 - Counterfactual: \"What if we had done X instead of Y?\"\n\nImplementación basada en:\n- Pearl & Mackenzie (2018) - The Book of Why\n- Sharma & Kiciman (2020) - DoWhy: An End-to-End Library for Causal Inference",
          "line_number": 1369,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_simulate_intervention",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_simulate_intervention(self, intervention, dag, causal_effects, description)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Simula intervención usando do-calculus (Pearl, 2009)\nImplementa: P(Y | do(X=x)) mediante propagación por el DAG",
          "line_number": 1433,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_scenario_narrative",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_generate_scenario_narrative(self, description, intervention, predicted_outcomes, probabilities)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Genera narrativa interpretable del escenario contrafactual",
          "line_number": 1499,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "sensitivity_analysis",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "sensitivity_analysis(self, causal_effects, dag)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Análisis de sensibilidad para supuestos de identificación causal\nBasado en: Cinelli, Forney & Pearl (2022) - \"A Crash Course in Good and Bad Controls\"",
          "line_number": 1529,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_e_value",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_compute_e_value(self, effect)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "E-value: mínima fuerza de confounding no observado para anular el efecto\nFórmula: E = effect_estimate + sqrt(effect_estimate * (effect_estimate - 1))\n\nReferencia: VanderWeele & Ding (2017) - Ann Intern Med",
          "line_number": 1552,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_robustness_value",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_compute_robustness_value(self, effect, dag)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Robustness Value: percentil de la distribución posterior que cruza cero\nValores altos (>0.95) indican alta robustez",
          "line_number": 1569,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_interpret_sensitivity",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_interpret_sensitivity(self, e_value, robustness)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Interpretación de resultados de sensibilidad",
          "line_number": 1588,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "calculate_quality_score",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "calculate_quality_score(self, text, tables, financial_analysis, responsible_entities, causal_dag, causal_effects)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity",
            "Multiple parameters increase error surface"
          ],
          "docstring": "Puntaje bayesiano integral de calidad del PDM\nIntegra todas las dimensiones de análisis con pesos calibrados",
          "line_number": 1605,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_score_financial_component",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_financial_component(self, financial_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Score componente financiero (0-10)",
          "line_number": 1656,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_indicators",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_indicators(self, tables, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Score calidad de indicadores (0-10)",
          "line_number": 1677,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_responsibility_clarity",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_responsibility_clarity(self, entities)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Score claridad de responsables (0-10)",
          "line_number": 1715,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_temporal_consistency",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_temporal_consistency(self, text, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Score consistencia temporal (0-10)",
          "line_number": 1732,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_pdet_alignment",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_pdet_alignment(self, text, tables, dag)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Score alineación con pilares PDET (0-10)",
          "line_number": 1753,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_causal_coherence",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_score_causal_coherence(self, dag, effects)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Score coherencia causal del plan (0-10)",
          "line_number": 1778,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_estimate_score_confidence",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_estimate_score_confidence(self, scores, weights)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Estima intervalo de confianza para el score usando bootstrap",
          "line_number": 1802,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_causal_network",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "export_causal_network(self, dag, output_path)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Exporta el DAG causal en formato GraphML para Gephi/Cytoscape",
          "line_number": 1824,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "generate_executive_report",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "generate_executive_report(self, analysis_results)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Genera reporte ejecutivo en Markdown",
          "line_number": 1841,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_interpret_overall_quality",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_interpret_overall_quality(self, score)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Interpretación del score global",
          "line_number": 1923,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_recommendations",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_generate_recommendations(self, analysis_results)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Genera recomendaciones específicas basadas en el análisis",
          "line_number": 1944,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "analyze_municipal_plan_sync",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "analyze_municipal_plan_sync(self, pdf_path, output_dir)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Synchronous wrapper for analyze_municipal_plan.",
          "line_number": 2022,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_full_text",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_extract_full_text(self, pdf_path)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Extrae texto completo del PDF usando múltiples métodos",
          "line_number": 2137,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_entity_to_dict",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_entity_to_dict(self, entity)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Convierte ResponsibleEntity a diccionario",
          "line_number": 2168,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_effect_to_dict",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_effect_to_dict(self, effect)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Convierte CausalEffect a diccionario",
          "line_number": 2179,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_scenario_to_dict",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_scenario_to_dict(self, scenario)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Convierte CounterfactualScenario a diccionario",
          "line_number": 2194,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_quality_to_dict",
          "class": "PDETMunicipalPlanAnalyzer",
          "file": "financiero_viabilidad_tablas.py",
          "signature": "_quality_to_dict(self, quality)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDETMunicipalPlanAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Convierte QualityScore a diccionario",
          "line_number": 2203,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "Analyzer_one.py": {
      "method_count": 46,
      "methods": [
        {
          "method_name": "__init__",
          "class": "MunicipalOntology",
          "file": "Analyzer_one.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 95,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "__init__",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, ontology)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 154,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "extract_semantic_cube",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "extract_semantic_cube(self, document_segments)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract multidimensional semantic cube from document segments.",
          "line_number": 165,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_empty_semantic_cube",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_empty_semantic_cube(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Return empty semantic cube structure.",
          "line_number": 237,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_vectorize_segments",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_vectorize_segments(self, segments)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Vectorize document segments using TF-IDF.",
          "line_number": 258,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_process_segment",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_process_segment(self, segment, idx, vector)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Process individual segment and extract features.",
          "line_number": 273,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_value_chain_link",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_classify_value_chain_link(self, segment)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify segment by value chain link using keyword matching.",
          "line_number": 310,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_policy_domain",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_classify_policy_domain(self, segment)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify segment by policy domain using keyword matching.",
          "line_number": 333,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_cross_cutting_themes",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_classify_cross_cutting_themes(self, segment)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify segment by cross-cutting themes.",
          "line_number": 348,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_semantic_complexity",
          "class": "SemanticAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_calculate_semantic_complexity(self, semantic_cube)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of SemanticAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate semantic complexity of the cube.",
          "line_number": 363,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, ontology)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 384,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "analyze_performance",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "analyze_performance(self, semantic_cube)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PerformanceAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Analyze performance indicators across value chain links.",
          "line_number": 391,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_throughput_metrics",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_calculate_throughput_metrics(self, segments, link_config)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PerformanceAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate throughput metrics for a value chain link.",
          "line_number": 422,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_bottlenecks",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_detect_bottlenecks(self, segments, link_config)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PerformanceAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Detect bottlenecks in value chain link.",
          "line_number": 460,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_loss_functions",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_calculate_loss_functions(self, metrics, link_config)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PerformanceAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate operational loss functions.",
          "line_number": 494,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_recommendations",
          "class": "PerformanceAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_generate_recommendations(self, performance_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PerformanceAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Generate optimization recommendations.",
          "line_number": 528,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, ontology)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 560,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "diagnose_critical_links",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "diagnose_critical_links(self, semantic_cube, performance_analysis)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TextMiningEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Diagnose critical value chain links.",
          "line_number": 577,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_critical_links",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "_identify_critical_links(self, performance_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TextMiningEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Identify critical links based on performance metrics.",
          "line_number": 613,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_analyze_link_text",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "_analyze_link_text(self, segments)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of TextMiningEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Analyze text content for a link.",
          "line_number": 640,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_assess_risks",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "_assess_risks(self, segments, text_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TextMiningEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Assess risks for a value chain link.",
          "line_number": 677,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_interventions",
          "class": "TextMiningEngine",
          "file": "Analyzer_one.py",
          "signature": "_generate_interventions(self, link_name, risk_assessment, text_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TextMiningEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Generate intervention recommendations.",
          "line_number": 705,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "MunicipalAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 742,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "analyze_document",
          "class": "MunicipalAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "analyze_document(self, document_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of MunicipalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Perform comprehensive analysis of a municipal document.",
          "line_number": 750,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_load_document",
          "class": "MunicipalAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_load_document(self, document_path)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of MunicipalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Load and segment document.",
          "line_number": 792,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_summary",
          "class": "MunicipalAnalyzer",
          "file": "Analyzer_one.py",
          "signature": "_generate_summary(self, semantic_cube, performance_analysis, critical_diagnosis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of MunicipalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Generate executive summary of analysis.",
          "line_number": 814,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "CanonicalQuestionSegmenter",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, questionnaire_path, rubric_path, segmentation_method)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1016,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "segment_plan",
          "class": "CanonicalQuestionSegmenter",
          "file": "Analyzer_one.py",
          "signature": "segment_plan(self, plan_text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CanonicalQuestionSegmenter must be initialized"
          ],
          "risks": [],
          "docstring": "Segment *plan_text* and emit evidence manifests per canonical contract.",
          "line_number": 1036,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_build_manifest",
          "class": "CanonicalQuestionSegmenter",
          "file": "Analyzer_one.py",
          "signature": "_build_manifest(self, contract, segments)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CanonicalQuestionSegmenter must be initialized"
          ],
          "risks": [],
          "docstring": "Build deterministic evidence manifest for *contract* across *segments*.",
          "line_number": 1108,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "load_pdf",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "load_pdf(pdf_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Load text from PDF file.",
          "line_number": 1211,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "load_docx",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "load_docx(docx_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Load text from DOCX file.",
          "line_number": 1229,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "segment_text",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "segment_text(text, method)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Segment text using different methods.",
          "line_number": 1246,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "load_canonical_question_contracts",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "load_canonical_question_contracts(questionnaire_path, rubric_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Load canonical question contracts based on questionnaire and rubric.",
          "line_number": 1289,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "segment_by_canonical_questionnaire",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "segment_by_canonical_questionnaire(plan_text, questionnaire_path, rubric_path, segmentation_method)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Convenience wrapper to segment plan text using canonical contracts.",
          "line_number": 1474,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_default_policy_area_id",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "_default_policy_area_id(legacy_policy_area)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Convert legacy policy-area code (e.g., P1) into canonical PAxx format.",
          "line_number": 1490,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_to_canonical_dimension_id",
          "class": "DocumentProcessor",
          "file": "Analyzer_one.py",
          "signature": "_to_canonical_dimension_id(dimension_code)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Convert legacy dimension code (e.g., D1) into canonical DIMxx format.",
          "line_number": 1501,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_to_json",
          "class": "ResultsExporter",
          "file": "Analyzer_one.py",
          "signature": "export_to_json(results, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Export results to JSON file.",
          "line_number": 1516,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_to_excel",
          "class": "ResultsExporter",
          "file": "Analyzer_one.py",
          "signature": "export_to_excel(results, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Export results to Excel file.",
          "line_number": 1526,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_summary_report",
          "class": "ResultsExporter",
          "file": "Analyzer_one.py",
          "signature": "export_summary_report(results, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Export a summary report in text format.",
          "line_number": 1591,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "ConfigurationManager",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, config_path)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1706,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "load_config",
          "class": "ConfigurationManager",
          "file": "Analyzer_one.py",
          "signature": "load_config(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigurationManager must be initialized"
          ],
          "risks": [],
          "docstring": "Load configuration from file or create default.",
          "line_number": 1710,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "save_config",
          "class": "ConfigurationManager",
          "file": "Analyzer_one.py",
          "signature": "save_config(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigurationManager must be initialized"
          ],
          "risks": [],
          "docstring": "Save current configuration to file.",
          "line_number": 1745,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BatchProcessor",
          "file": "Analyzer_one.py",
          "signature": "__init__(self, analyzer)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1757,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "process_directory",
          "class": "BatchProcessor",
          "file": "Analyzer_one.py",
          "signature": "process_directory(self, directory_path, pattern)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BatchProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Process all files matching pattern in directory.",
          "line_number": 1760,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_batch_results",
          "class": "BatchProcessor",
          "file": "Analyzer_one.py",
          "signature": "export_batch_results(self, batch_results, output_dir)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BatchProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Export batch processing results.",
          "line_number": 1783,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_create_batch_summary",
          "class": "BatchProcessor",
          "file": "Analyzer_one.py",
          "signature": "_create_batch_summary(self, batch_results, output_path)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BatchProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Create summary of batch processing results.",
          "line_number": 1805,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "contradiction_deteccion.py": {
      "method_count": 54,
      "methods": [
        {
          "method_name": "__init__",
          "class": "BayesianConfidenceCalculator",
          "file": "contradiction_deteccion.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 107,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "calculate_posterior",
          "class": "BayesianConfidenceCalculator",
          "file": "contradiction_deteccion.py",
          "signature": "calculate_posterior(self, evidence_strength, observations, domain_weight)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianConfidenceCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula probabilidad posterior usando inferencia Bayesiana\n\nArgs:\n    evidence_strength: Fuerza de la evidencia [0, 1]\n    observations: Número de observaciones que soportan la evidencia\n    domain_weight: Peso específico del dominio de política",
          "line_number": 112,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 145,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "verify_temporal_consistency",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "verify_temporal_consistency(self, statements)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Verifica consistencia temporal entre declaraciones\n\nReturns:\n    (is_consistent, conflicts_found)",
          "line_number": 153,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_build_timeline",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_build_timeline(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Construye línea temporal a partir de declaraciones",
          "line_number": 182,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_parse_temporal_marker",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_parse_temporal_marker(self, marker)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Parsea marcador temporal a timestamp numérico",
          "line_number": 196,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_has_temporal_conflict",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_has_temporal_conflict(self, event_a, event_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta conflictos temporales entre eventos",
          "line_number": 213,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_are_mutually_exclusive",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_are_mutually_exclusive(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Determina si dos declaraciones son mutuamente excluyentes",
          "line_number": 224,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_resources",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_extract_resources(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extrae recursos mencionados en el texto",
          "line_number": 236,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_check_deadline_constraints",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_check_deadline_constraints(self, timeline)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Verifica violaciones de restricciones de plazo",
          "line_number": 251,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_should_precede",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_should_precede(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Determina si stmt_a debe preceder a stmt_b",
          "line_number": 268,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_temporal_type",
          "class": "TemporalLogicVerifier",
          "file": "contradiction_deteccion.py",
          "signature": "_classify_temporal_type(self, marker)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "Clasifica el tipo de marcador temporal",
          "line_number": 273,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "__init__(self, model_name, spacy_model, device)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 287,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_initialize_pdm_patterns",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_initialize_pdm_patterns(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Inicializa patrones específicos de PDMs colombianos",
          "line_number": 323,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "detect",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "detect(self, text, plan_name, dimension)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Detecta contradicciones con análisis multi-dimensional avanzado\n\nArgs:\n    text: Texto del plan de desarrollo\n    plan_name: Nombre del PDM\n    dimension: Dimensión del plan siendo analizada\n\nReturns:\n    Análisis completo con contradicciones detectadas y métricas",
          "line_number": 348,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_policy_statements",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_extract_policy_statements(self, text, dimension)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extrae declaraciones de política estructuradas del texto",
          "line_number": 418,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_embeddings",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_generate_embeddings(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Genera embeddings semánticos para las declaraciones",
          "line_number": 459,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_build_knowledge_graph",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_build_knowledge_graph(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Construye grafo de conocimiento para razonamiento",
          "line_number": 486,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_semantic_contradictions",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_detect_semantic_contradictions(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta contradicciones semánticas usando transformers",
          "line_number": 512,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_numerical_inconsistencies",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_detect_numerical_inconsistencies(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta inconsistencias numéricas con análisis estadístico",
          "line_number": 556,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_temporal_conflicts",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_detect_temporal_conflicts(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta conflictos temporales usando verificación lógica",
          "line_number": 608,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_logical_incompatibilities",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_detect_logical_incompatibilities(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta incompatibilidades lógicas usando razonamiento en grafo",
          "line_number": 652,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_resource_conflicts",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_detect_resource_conflicts(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Detecta conflictos en asignación de recursos",
          "line_number": 705,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_coherence_metrics",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_coherence_metrics(self, contradictions, statements, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Calcula métricas avanzadas de coherencia del documento",
          "line_number": 760,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_global_semantic_coherence",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_global_semantic_coherence(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula coherencia semántica global usando embeddings",
          "line_number": 817,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_objective_alignment",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_objective_alignment(self, statements)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula alineación entre objetivos declarados",
          "line_number": 845,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_graph_fragmentation",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_graph_fragmentation(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula fragmentación del grafo de conocimiento",
          "line_number": 871,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_contradiction_entropy",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_contradiction_entropy(self, contradictions)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula entropía de distribución de tipos de contradicción",
          "line_number": 885,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_syntactic_complexity",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_syntactic_complexity(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Calcula complejidad sintáctica del documento",
          "line_number": 911,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_dependency_depth",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_get_dependency_depth(self, token)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula profundidad de un token en el árbol de dependencias",
          "line_number": 940,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_confidence_interval",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_confidence_interval(self, score, n_observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula intervalo de confianza del 95% para el score",
          "line_number": 949,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_resolution_recommendations",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_generate_resolution_recommendations(self, contradictions)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Genera recomendaciones específicas para resolver contradicciones",
          "line_number": 972,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_affected_sections",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_identify_affected_sections(self, conflicts)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Identifica secciones del plan afectadas por contradicciones",
          "line_number": 1046,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_serialize_contradiction",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_serialize_contradiction(self, contradiction)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Serializa evidencia de contradicción para output",
          "line_number": 1062,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_graph_statistics",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_get_graph_statistics(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Obtiene estadísticas del grafo de conocimiento",
          "line_number": 1087,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_temporal_markers",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_extract_temporal_markers(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extrae marcadores temporales del texto",
          "line_number": 1104,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_quantitative_claims",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_extract_quantitative_claims(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extrae afirmaciones cuantitativas estructuradas",
          "line_number": 1125,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_parse_number",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_parse_number(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Parsea número desde texto",
          "line_number": 1155,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_resource_mentions",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_extract_resource_mentions(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extrae menciones de recursos con montos",
          "line_number": 1164,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_determine_semantic_role",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_determine_semantic_role(self, sent)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Determina el rol semántico de una oración",
          "line_number": 1187,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_dependencies",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_identify_dependencies(self, sent, doc)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Identifica dependencias entre declaraciones",
          "line_number": 1206,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_context_window",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_get_context_window(self, text, start, end, window_size)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Obtiene ventana de contexto alrededor de una posición",
          "line_number": 1229,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_similarity",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_similarity(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula similaridad entre dos declaraciones",
          "line_number": 1235,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_contradiction",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_classify_contradiction(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Clasifica probabilidad de contradicción en texto",
          "line_number": 1241,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_domain_weight",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_get_domain_weight(self, dimension)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Obtiene peso específico del dominio",
          "line_number": 1254,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_suggest_resolutions",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_suggest_resolutions(self, contradiction_type)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Sugiere resoluciones específicas por tipo de contradicción",
          "line_number": 1266,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_are_comparable_claims",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_are_comparable_claims(self, claim_a, claim_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Determina si dos afirmaciones cuantitativas son comparables",
          "line_number": 1297,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_text_similarity",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_text_similarity(self, text_a, text_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula similaridad simple entre textos",
          "line_number": 1311,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_numerical_divergence",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_numerical_divergence(self, claim_a, claim_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula divergencia entre valores numéricos",
          "line_number": 1329,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_statistical_significance_test",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_statistical_significance_test(self, claim_a, claim_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Realiza test de significancia estadística",
          "line_number": 1349,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_has_logical_conflict",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_has_logical_conflict(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Determina si hay conflicto lógico entre declaraciones",
          "line_number": 1380,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_are_conflicting_allocations",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_are_conflicting_allocations(self, amount_a, amount_b, total)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Determina si las asignaciones de recursos están en conflicto",
          "line_number": 1409,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_determine_relation_type",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_determine_relation_type(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Determina el tipo de relación entre dos declaraciones",
          "line_number": 1426,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_severity",
          "class": "PolicyContradictionDetector",
          "file": "contradiction_deteccion.py",
          "signature": "_calculate_severity(self, stmt_a, stmt_b)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyContradictionDetector must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula la severidad de una contradicción entre declaraciones",
          "line_number": 1448,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "embedding_policy.py": {
      "method_count": 68,
      "methods": [
        {
          "method_name": "encode",
          "class": "EmbeddingProtocol",
          "file": "embedding_policy.py",
          "signature": "encode(self, texts, batch_size, normalize)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingProtocol must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 108,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "__init__",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 154,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "chunk_document",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "chunk_document(self, text, document_metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Chunk document with advanced semantic awareness.\n\nReturns chunks with preserved structure and P-D-Q context.",
          "line_number": 158,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_normalize_text",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_normalize_text(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Normalize text while preserving structure.",
          "line_number": 226,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_recursive_split",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_recursive_split(self, text, target_size, overlap)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Recursive character splitting with semantic boundary respect.\n\nPriority: Paragraph > Sentence > Word > Character",
          "line_number": 233,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_find_sentence_boundary",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_find_sentence_boundary(self, text, start, end)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Find sentence boundary using Spanish punctuation rules.",
          "line_number": 275,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_sections",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_extract_sections(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract document sections with hierarchical structure.",
          "line_number": 286,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_tables",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_extract_tables(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Identify table regions in document.",
          "line_number": 302,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_lists",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_extract_lists(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Identify list structures.",
          "line_number": 316,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_infer_pdq_context",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_infer_pdq_context(self, chunk_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized"
          ],
          "risks": [],
          "docstring": "Infer P-D-Q context from chunk content.\n\nUses heuristics based on Colombian policy vocabulary.",
          "line_number": 323,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_contains_table",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_contains_table(self, chunk_text, tables)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized"
          ],
          "risks": [],
          "docstring": "Check if chunk contains table markers.",
          "line_number": 384,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_contains_list",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_contains_list(self, chunk_text, lists)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized"
          ],
          "risks": [],
          "docstring": "Check if chunk contains list structures.",
          "line_number": 393,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_find_section",
          "class": "AdvancedSemanticChunker",
          "file": "embedding_policy.py",
          "signature": "_find_section(self, chunk_text, sections)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedSemanticChunker must be initialized"
          ],
          "risks": [],
          "docstring": "Find section title for chunk.",
          "line_number": 397,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "__init__(self, prior_strength)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize Bayesian analyzer.\n\nArgs:\n    prior_strength: Prior belief strength (1.0 = weak, 10.0 = strong)",
          "line_number": 425,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "evaluate_policy_metric",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "evaluate_policy_metric(self, observed_values, n_posterior_samples)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Bayesian evaluation of policy metric with uncertainty quantification.\n\nReturns posterior distribution, credible intervals, and evidence strength.",
          "line_number": 436,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_beta_binomial_posterior",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "_beta_binomial_posterior(self, observations, n_samples)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Beta-Binomial conjugate posterior for proportion metrics.\n\nPrior: Beta(α, β)\nLikelihood: Binomial\nPosterior: Beta(α + successes, β + failures)",
          "line_number": 485,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_normal_normal_posterior",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "_normal_normal_posterior(self, observations, n_samples)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Normal-Normal conjugate posterior for continuous metrics.\n\nPrior: Normal(μ₀, σ₀²)\nLikelihood: Normal(μ, σ²)\nPosterior: Normal(μ_post, σ_post²)",
          "line_number": 512,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_evidence_strength",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "_classify_evidence_strength(self, credible_interval_width)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify evidence strength based on posterior uncertainty.",
          "line_number": 545,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_coherence",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "_compute_coherence(self, observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Compute numerical coherence (consistency) score.\n\nUses coefficient of variation and statistical tests.",
          "line_number": 558,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_null_evaluation",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "_null_evaluation(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Return null evaluation when no data available.",
          "line_number": 581,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "compare_policies",
          "class": "BayesianNumericalAnalyzer",
          "file": "embedding_policy.py",
          "signature": "compare_policies(self, policy_a_values, policy_b_values)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianNumericalAnalyzer must be initialized"
          ],
          "risks": [],
          "docstring": "Bayesian comparison of two policy metrics.\n\nReturns probability that A > B and Bayes factor.",
          "line_number": 591,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PolicyCrossEncoderReranker",
          "file": "embedding_policy.py",
          "signature": "__init__(self, model_name, max_length, retry_handler)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize cross-encoder reranker.\n\nArgs:\n    model_name: HuggingFace model name (multilingual preferred)\n    max_length: Maximum sequence length for cross-encoder\n    retry_handler: Optional RetryHandler for model loading",
          "line_number": 655,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "rerank",
          "class": "PolicyCrossEncoderReranker",
          "file": "embedding_policy.py",
          "signature": "rerank(self, query, candidates, top_k, min_score)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyCrossEncoderReranker must be initialized"
          ],
          "risks": [],
          "docstring": "Rerank candidates using cross-encoder attention.\n\nReturns top-k chunks with relevance scores.",
          "line_number": 694,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "__init__(self, config, retry_handler)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 777,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "process_document",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "process_document(self, document_text, document_metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Process complete PDM document into semantic chunks with embeddings.\n\nArgs:\n    document_text: Full document text\n    document_metadata: Metadata including doc_id, municipality, year\n\nReturns:\n    List of semantic chunks with embeddings and P-D-Q context",
          "line_number": 826,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "semantic_search",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "semantic_search(self, query, document_chunks, pdq_filter, use_reranking)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Advanced semantic search with P-D-Q filtering and reranking.\n\nPipeline:\n1. Bi-encoder retrieval (fast, approximate)\n2. P-D-Q filtering (if specified)\n3. Cross-encoder reranking (precise)\n4. MMR diversification\n\nArgs:\n    query: Search query\n    document_chunks: Pool of chunks to search\n    pdq_filter: Optional P-D-Q context filter\n    use_reranking: Enable cross-encoder reranking\n\nReturns:\n    Ranked list of (chunk, score) tuples",
          "line_number": 874,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "evaluate_policy_numerical_consistency",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "evaluate_policy_numerical_consistency(self, chunks, pdq_context)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Bayesian evaluation of numerical consistency for policy metric.\n\nExtracts numerical values from chunks matching P-D-Q context,\nperforms rigorous statistical analysis with uncertainty quantification.\n\nArgs:\n    chunks: Document chunks to analyze\n    pdq_context: P-D-Q context to filter relevant chunks\n\nReturns:\n    Bayesian evaluation with credible intervals and evidence strength",
          "line_number": 944,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "compare_policy_interventions",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "compare_policy_interventions(self, intervention_a_chunks, intervention_b_chunks, pdq_context)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Bayesian comparison of two policy interventions.\n\nReturns probability and evidence for superiority.",
          "line_number": 996,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_pdq_report",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "generate_pdq_report(self, document_chunks, target_pdq)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Generate comprehensive analytical report for P-D-Q question.\n\nCombines semantic search, numerical analysis, and evidence synthesis.",
          "line_number": 1016,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_embed_texts",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_embed_texts(self, texts)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Generate embeddings with caching and retry logic.",
          "line_number": 1070,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_filter_by_pdq",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_filter_by_pdq(self, chunks, pdq_filter)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Filter chunks by P-D-Q context.",
          "line_number": 1127,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_mmr",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_apply_mmr(self, ranked_results)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Apply Maximal Marginal Relevance for diversification.\n\nBalances relevance with diversity to avoid redundant results.",
          "line_number": 1139,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_numerical_values",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_extract_numerical_values(self, chunks)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Extract numerical values from chunks using advanced patterns.\n\nFocuses on policy-relevant metrics: percentages, amounts, counts.",
          "line_number": 1193,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_query_from_pdq",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_generate_query_from_pdq(self, pdq)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Generate search query from P-D-Q identifier.",
          "line_number": 1248,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_overall_confidence",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_compute_overall_confidence(self, relevant_chunks, numerical_eval)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Compute overall confidence score combining semantic and numerical evidence.\n\nConsiders:\n- Number of relevant chunks\n- Semantic relevance scores\n- Numerical evidence strength\n- Statistical coherence",
          "line_number": 1256,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_cached_similarity",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "_cached_similarity(self, text_hash1, text_hash2)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Cached similarity computation for performance.\nAssumes embeddings are cached in self._embedding_cache using text_hash as key.",
          "line_number": 1297,
          "decorators": [
            "<ast.Call object at 0x7f1eea036850>"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_diagnostics",
          "class": "PolicyAnalysisEmbedder",
          "file": "embedding_policy.py",
          "signature": "get_diagnostics(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisEmbedder must be initialized"
          ],
          "risks": [],
          "docstring": "Get system diagnostics and performance metrics.",
          "line_number": 1305,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "__init__(self, config, model_tier, retry_handler)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize producer with optional configuration",
          "line_number": 1398,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "process_document",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "process_document(self, document_text, document_metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Process document into semantic chunks with embeddings",
          "line_number": 1417,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_chunk_count",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_chunk_count(self, chunks)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get number of chunks",
          "line_number": 1425,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_chunk_text",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_chunk_text(self, chunk)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract text from chunk",
          "line_number": 1429,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_chunk_embedding",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_chunk_embedding(self, chunk)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract embedding from chunk",
          "line_number": 1433,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_chunk_metadata",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_chunk_metadata(self, chunk)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract metadata from chunk",
          "line_number": 1437,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_chunk_pdq_context",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_chunk_pdq_context(self, chunk)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract P-D-Q context from chunk",
          "line_number": 1441,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "semantic_search",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "semantic_search(self, query, document_chunks, pdq_filter, use_reranking)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Advanced semantic search with reranking",
          "line_number": 1449,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_search_result_chunk",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_search_result_chunk(self, result)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract chunk from search result",
          "line_number": 1461,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_search_result_score",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_search_result_score(self, result)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract relevance score from search result",
          "line_number": 1467,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_pdq_report",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "generate_pdq_report(self, document_chunks, target_pdq)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Generate comprehensive analytical report for P-D-Q question",
          "line_number": 1477,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_pdq_evidence_count",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_pdq_evidence_count(self, report)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract evidence count from P-D-Q report",
          "line_number": 1485,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_pdq_numerical_evaluation",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_pdq_numerical_evaluation(self, report)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract numerical evaluation from P-D-Q report",
          "line_number": 1489,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_pdq_evidence_passages",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_pdq_evidence_passages(self, report)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract evidence passages from P-D-Q report",
          "line_number": 1493,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_pdq_confidence",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_pdq_confidence(self, report)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract confidence from P-D-Q report",
          "line_number": 1497,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "evaluate_numerical_consistency",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "evaluate_numerical_consistency(self, chunks, pdq_context)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Evaluate numerical consistency with Bayesian analysis",
          "line_number": 1505,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_point_estimate",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_point_estimate(self, evaluation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract point estimate from Bayesian evaluation",
          "line_number": 1515,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_credible_interval",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_credible_interval(self, evaluation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract 95% credible interval from Bayesian evaluation",
          "line_number": 1519,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_evidence_strength",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_evidence_strength(self, evaluation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract evidence strength classification",
          "line_number": 1525,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_numerical_coherence",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_numerical_coherence(self, evaluation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract numerical coherence score",
          "line_number": 1531,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "compare_policy_interventions",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "compare_policy_interventions(self, intervention_a_chunks, intervention_b_chunks, pdq_context)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Bayesian comparison of two policy interventions",
          "line_number": 1539,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_comparison_probability",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_comparison_probability(self, comparison)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract probability that A is better than B",
          "line_number": 1550,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_comparison_bayes_factor",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_comparison_bayes_factor(self, comparison)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract Bayes factor from comparison",
          "line_number": 1554,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_comparison_difference_mean",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_comparison_difference_mean(self, comparison)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract mean difference from comparison",
          "line_number": 1558,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_diagnostics",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_diagnostics(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get system diagnostics and performance metrics",
          "line_number": 1566,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_config",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_config(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get current configuration",
          "line_number": 1570,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "list_policy_domains",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "list_policy_domains(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "List all policy domains",
          "line_number": 1574,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "list_analytical_dimensions",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "list_analytical_dimensions(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "List all analytical dimensions",
          "line_number": 1578,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_policy_domain_description",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_policy_domain_description(self, domain)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get description for policy domain",
          "line_number": 1582,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_analytical_dimension_description",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "get_analytical_dimension_description(self, dimension)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get description for analytical dimension",
          "line_number": 1586,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "create_pdq_identifier",
          "class": "EmbeddingPolicyProducer",
          "file": "embedding_policy.py",
          "signature": "create_pdq_identifier(self, policy, dimension, question)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EmbeddingPolicyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Create P-D-Q identifier",
          "line_number": 1590,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "teoria_cambio.py": {
      "method_count": 39,
      "methods": [
        {
          "method_name": "__post_init__",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "__post_init__(self)",
          "complexity": "MEDIUM",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedGraphNode must be initialized"
          ],
          "risks": [],
          "docstring": "Inicializa metadatos por defecto si no son provistos.",
          "line_number": 159,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_normalize_metadata",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "_normalize_metadata(self, metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedGraphNode must be initialized"
          ],
          "risks": [],
          "docstring": "Normaliza metadatos garantizando primitivos JSON y valores por defecto.",
          "line_number": 181,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_sanitize_confidence",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "_sanitize_confidence(value)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 204,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_sanitize_created",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "_sanitize_created(value)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 212,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_sanitize_metadata_value",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "_sanitize_metadata_value(value)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 223,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "to_serializable_dict",
          "class": "AdvancedGraphNode",
          "file": "teoria_cambio.py",
          "signature": "to_serializable_dict(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedGraphNode must be initialized"
          ],
          "risks": [],
          "docstring": "Convierte el nodo en un diccionario serializable compatible con JSON Schema.",
          "line_number": 233,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Inicializa el motor con un sistema de cache optimizado.",
          "line_number": 296,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_es_conexion_valida",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "_es_conexion_valida(origen, destino)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Verifica la validez de una conexión causal según la jerarquía estructural.",
          "line_number": 303,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "construir_grafo_causal",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "construir_grafo_causal(self)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TeoriaCambio must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Construye y cachea el grafo causal canónico.",
          "line_number": 308,
          "decorators": [
            "<ast.Call object at 0x7f1ee9ea9090>"
          ],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "validacion_completa",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "validacion_completa(self, grafo)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TeoriaCambio must be initialized"
          ],
          "risks": [],
          "docstring": "Ejecuta una validación estructural exhaustiva de la teoría de cambio.",
          "line_number": 331,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extraer_categorias",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "_extraer_categorias(grafo)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Extrae el conjunto de categorías presentes en el grafo.",
          "line_number": 347,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_validar_orden_causal",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "_validar_orden_causal(grafo)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Identifica las aristas que violan el orden causal axiomático.",
          "line_number": 356,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_encontrar_caminos_completos",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "_encontrar_caminos_completos(grafo)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Encuentra todos los caminos simples desde nodos INSUMOS a CAUSALIDAD.",
          "line_number": 367,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generar_sugerencias_internas",
          "class": "TeoriaCambio",
          "file": "teoria_cambio.py",
          "signature": "_generar_sugerencias_internas(validacion)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Genera un listado de sugerencias accionables basadas en los resultados.",
          "line_number": 391,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "__init__(self, graph_type)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 460,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "add_node",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "add_node(self, name, dependencies, role, metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Agrega un nodo enriquecido al grafo.",
          "line_number": 472,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "add_edge",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "add_edge(self, from_node, to_node, weight)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Agrega una arista dirigida con peso opcional.",
          "line_number": 484,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_initialize_rng",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_initialize_rng(self, plan_name, salt)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Inicializa el generador de números aleatorios con una semilla determinista.\n\nAudit Point 1.1: Deterministic Seeding (RNG)\nInitializes numpy/random RNG with deterministic seed for reproducibility.\nSets reproducible=True in MonteCarloAdvancedResult.\n\nArgs:\n    plan_name: Plan identifier for seed derivation\n    salt: Optional salt for sensitivity analysis\n\nReturns:\n    Generated seed value for audit logging",
          "line_number": 493,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_is_acyclic",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_is_acyclic(nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Detección de ciclos mediante el algoritmo de Kahn (ordenación topológica).",
          "line_number": 520,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_subgraph",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_generate_subgraph(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Genera un subgrafo aleatorio del grafo principal.",
          "line_number": 543,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "calculate_acyclicity_pvalue",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "calculate_acyclicity_pvalue(self, plan_name, iterations)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Cálculo avanzado de p-value con un marco estadístico completo.",
          "line_number": 563,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "last_serialized_nodes",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "last_serialized_nodes(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Obtiene la instantánea más reciente de nodos serializados.",
          "line_number": 614,
          "decorators": [
            "property"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_nodes",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "export_nodes(self, validate, schema_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Serializa los nodos del grafo y opcionalmente valida contra JSON Schema.",
          "line_number": 622,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_node_validator",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_get_node_validator(cls, schema_path)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Obtiene (y cachea) el validador JSON Schema para nodos avanzados.",
          "line_number": 655,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_perform_sensitivity_analysis_internal",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_perform_sensitivity_analysis_internal(self, plan_name, base_p_value, iterations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Análisis de sensibilidad interno optimizado para evitar cálculos redundantes.",
          "line_number": 687,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_confidence_interval",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_calculate_confidence_interval(s, n, conf)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Calcula el intervalo de confianza de Wilson.",
          "line_number": 730,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_statistical_power",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_calculate_statistical_power(s, n, alpha)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Calcula el poder estadístico a posteriori.",
          "line_number": 744,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_bayesian_posterior",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_calculate_bayesian_posterior(likelihood, prior)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "numpy",
            "scipy",
            "statistical libraries"
          ],
          "prerequisites": [],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Calcula la probabilidad posterior Bayesiana simple.",
          "line_number": 755,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_calculate_node_importance",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_calculate_node_importance(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula una métrica de importancia para cada nodo.",
          "line_number": 763,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_graph_stats",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "get_graph_stats(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Obtiene estadísticas estructurales del grafo.",
          "line_number": 784,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_create_empty_result",
          "class": "AdvancedDAGValidator",
          "file": "teoria_cambio.py",
          "signature": "_create_empty_result(self, plan_name, seed, timestamp)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedDAGValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Crea un resultado vacío para grafos sin nodos.",
          "line_number": 794,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 830,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "execute_suite",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "execute_suite(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Ejecuta la suite completa de validación industrial.",
          "line_number": 840,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_engine_readiness",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "validate_engine_readiness(self)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Valida la disponibilidad y tiempo de instanciación de los motores de análisis.",
          "line_number": 872,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_causal_categories",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "validate_causal_categories(self)",
          "complexity": "HIGH",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Valida la completitud y el orden axiomático de las categorías causales.",
          "line_number": 891,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "validate_connection_matrix",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "validate_connection_matrix(self)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Valida la matriz de transiciones causales.",
          "line_number": 908,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "run_performance_benchmarks",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "run_performance_benchmarks(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Ejecuta benchmarks de rendimiento para las operaciones críticas del motor.",
          "line_number": 928,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_benchmark_operation",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "_benchmark_operation(self, operation_name, callable_obj, threshold)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Mide el tiempo de ejecución de una operación y registra la métrica.",
          "line_number": 957,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_log_metric",
          "class": "IndustrialGradeValidator",
          "file": "teoria_cambio.py",
          "signature": "_log_metric(self, name, value, unit, threshold)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialGradeValidator must be initialized"
          ],
          "risks": [],
          "docstring": "Registra y reporta una métrica de validación.",
          "line_number": 967,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "dereck_beach.py": {
      "method_count": 159,
      "methods": [
        {
          "method_name": "classify_test",
          "class": "BeachEvidentialTest",
          "file": "dereck_beach.py",
          "signature": "classify_test(necessity, sufficiency)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Classify evidential test type based on necessity and sufficiency.\n\nBeach calibration:\n- Necessity > 0.7 → High necessity\n- Sufficiency > 0.7 → High sufficiency",
          "line_number": 122,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "apply_test_logic",
          "class": "BeachEvidentialTest",
          "file": "dereck_beach.py",
          "signature": "apply_test_logic(test_type, evidence_found, prior, bayes_factor)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Apply Beach test-specific logic to Bayesian updating.\n\nCRITICAL RULES:\n1. Hoop Test FAIL → posterior ≈ 0 (knock-out)\n2. Smoking Gun PASS → multiply prior by large BF (>10)\n3. Doubly Decisive → extreme updates (BF > 100 or < 0.01)\n\nReturns: (posterior_confidence, interpretation)",
          "line_number": 143,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "CDAFException",
          "file": "dereck_beach.py",
          "signature": "__init__(self, message, details, stage, recoverable)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 197,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_format_message",
          "class": "CDAFException",
          "file": "dereck_beach.py",
          "signature": "_format_message(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFException must be initialized"
          ],
          "risks": [],
          "docstring": "Format error message with structured information",
          "line_number": 205,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "to_dict",
          "class": "CDAFException",
          "file": "dereck_beach.py",
          "signature": "to_dict(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFException must be initialized"
          ],
          "risks": [],
          "docstring": "Convert exception to structured dictionary",
          "line_number": 215,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "check_sum_to_one",
          "class": "MechanismTypeConfig",
          "file": "dereck_beach.py",
          "signature": "check_sum_to_one(cls, v, values)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Validate that probabilities sum to approximately 1.0",
          "line_number": 289,
          "decorators": [
            "<ast.Call object at 0x7f1ee9d69690>"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config_path)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 447,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_load_config",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "_load_config(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Load YAML configuration file",
          "line_number": 458,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_load_default_config",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "_load_default_config(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Load default configuration if custom fails",
          "line_number": 475,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_validate_config",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "_validate_config(self)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Validate configuration structure using Pydantic schema",
          "line_number": 562,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "get(self, key, default)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Get configuration value with dot notation support",
          "line_number": 593,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_bayesian_threshold",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "get_bayesian_threshold(self, key)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "numpy",
            "scipy",
            "statistical libraries"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Get Bayesian threshold with type safety",
          "line_number": 604,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "get_mechanism_prior",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "get_mechanism_prior(self, mechanism_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Get mechanism type prior probability with type safety",
          "line_number": 610,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_performance_setting",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "get_performance_setting(self, key)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Get performance setting with type safety",
          "line_number": 616,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "update_priors_from_feedback",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "update_priors_from_feedback(self, feedback_data)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Self-reflective loop: Update priors based on audit feedback\nImplements frontier paradigm of learning from results\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Applies penalties to mechanism types with implementation_failure flags\n- Heavily penalizes \"miracle\" mechanisms failing necessity/sufficiency tests\n- Ensures mean mech_uncertainty decreases by ≥5% over iterations",
          "line_number": 622,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_save_prior_history",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "_save_prior_history(self, feedback_data, uncertainty_reduction)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Save prior history for learning across documents\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Tracks uncertainty reduction over iterations\n- Records penalty applications and test failures",
          "line_number": 718,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_load_uncertainty_history",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "_load_uncertainty_history(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Load historical uncertainty measurements\n\nHARMONIC FRONT 4: Required for tracking ≥5% reduction over 10 iterations",
          "line_number": 781,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "check_uncertainty_reduction_criterion",
          "class": "ConfigLoader",
          "file": "dereck_beach.py",
          "signature": "check_uncertainty_reduction_criterion(self, current_uncertainty)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ConfigLoader must be initialized"
          ],
          "risks": [],
          "docstring": "Check if mean mechanism_type uncertainty has decreased ≥5% over 10 iterations\n\nHARMONIC FRONT 4 QUALITY CRITERIA:\nSuccess verified if mean mech_uncertainty decreases by ≥5% over 10 sequential PDM analyses",
          "line_number": 806,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PDFProcessor",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config, retry_handler)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 852,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "load_document",
          "class": "PDFProcessor",
          "file": "dereck_beach.py",
          "signature": "load_document(self, pdf_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDFProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Load PDF document with retry logic",
          "line_number": 861,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "extract_text",
          "class": "PDFProcessor",
          "file": "dereck_beach.py",
          "signature": "extract_text(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PDFProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Extract all text from PDF",
          "line_number": 894,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "extract_tables",
          "class": "PDFProcessor",
          "file": "dereck_beach.py",
          "signature": "extract_tables(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDFProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Extract tables from PDF",
          "line_number": 912,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "extract_sections",
          "class": "PDFProcessor",
          "file": "dereck_beach.py",
          "signature": "extract_sections(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PDFProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Extract document sections based on patterns",
          "line_number": 943,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config, nlp_model)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 966,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "extract_causal_hierarchy",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "extract_causal_hierarchy(self, text)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Extract complete causal hierarchy from text",
          "line_number": 974,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "_extract_goals",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_extract_goals(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract all goals from text",
          "line_number": 993,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_parse_goal_context",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_parse_goal_context(self, goal_id, context)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Parse goal context to extract structured information",
          "line_number": 1015,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_add_node_to_graph",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_add_node_to_graph(self, node)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Add node to causal graph",
          "line_number": 1051,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_causal_links",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_extract_causal_links(self, text)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "AGUJA I: El Prior Informado Adaptativo\nExtract causal links using Bayesian inference with adaptive priors",
          "line_number": 1059,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_calculate_semantic_distance",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_calculate_semantic_distance(self, source, target)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate semantic distance between nodes using spaCy embeddings\n\nPERFORMANCE NOTE: This method can be optimized with:\n1. Vectorized operations using numpy for batch processing\n2. Embedding caching to avoid recomputing spaCy vectors\n3. Async processing for large documents with many nodes\n4. Alternative: BERT/transformer embeddings for higher fidelity (SOTA)\n\nCurrent implementation prioritizes determinism over speed.\nEnable performance.cache_embeddings in config for production use.",
          "line_number": 1194,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_type_transition_prior",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_calculate_type_transition_prior(self, source, target)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate prior based on historical transition frequencies between goal types",
          "line_number": 1232,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_check_structural_violation",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_check_structural_violation(self, source, target)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "AUDIT POINT 2.1: Structural Veto (D6-Q2)\n\nCheck if causal link violates structural hierarchy based on TeoriaCambio axioms.\nImplements set-theoretic constraints per Goertz & Mahoney 2012.\n\nReturns:\n    None if link is valid, otherwise a string describing the violation",
          "line_number": 1255,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_language_specificity",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_calculate_language_specificity(self, keyword, policy_area, context)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Assess specificity of causal language (epistemic certainty)\n\nHarmonic Front 3 - Enhancement 4: Language Specificity Assessment\nEnhanced to check policy-specific vocabulary (patrones_verificacion) for current\nPolicy Area (P1–P10), not just generic causal keywords.\n\nFor D6-Q5 (Contextual/Differential Focus): rewards use of specialized terminology\nthat anchors intervention in social/cultural context (e.g., \"catastro multipropósito\",\n\"reparación integral\", \"mujeres rurales\", \"guardia indígena\").",
          "line_number": 1295,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_assess_temporal_coherence",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_assess_temporal_coherence(self, source, target)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Assess temporal coherence based on verb sequences",
          "line_number": 1405,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_assess_financial_consistency",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_assess_financial_consistency(self, source, target)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Assess financial alignment between connected nodes",
          "line_number": 1436,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_textual_proximity",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_calculate_textual_proximity(self, source, target, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Calculate how often node IDs appear together in text windows",
          "line_number": 1460,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_initialize_prior",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_initialize_prior(self, source, target)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Initialize prior distribution for causal link",
          "line_number": 1482,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_composite_likelihood",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_calculate_composite_likelihood(self, evidence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate composite likelihood from multiple evidence components\n\nEnhanced with:\n- Nonlinear transformation rewarding triangulation\n- Evidence diversity verification across analytical domains",
          "line_number": 1500,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_build_type_hierarchy",
          "class": "CausalExtractor",
          "file": "dereck_beach.py",
          "signature": "_build_type_hierarchy(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Build hierarchy based on goal types",
          "line_number": 1559,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "MechanismPartExtractor",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config, nlp_model)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1584,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "extract_entity_activity",
          "class": "MechanismPartExtractor",
          "file": "dereck_beach.py",
          "signature": "extract_entity_activity(self, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of MechanismPartExtractor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract Entity-Activity tuple from text",
          "line_number": 1590,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_normalize_entity",
          "class": "MechanismPartExtractor",
          "file": "dereck_beach.py",
          "signature": "_normalize_entity(self, entity)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of MechanismPartExtractor must be initialized"
          ],
          "risks": [],
          "docstring": "Normalize entity name using aliases",
          "line_number": 1628,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1637,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "trace_financial_allocation",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "trace_financial_allocation(self, tables, nodes, graph)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of FinancialAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Trace financial allocations to programs/goals\n\nHarmonic Front 3 - Enhancement 5: Single-Case Counterfactual Budget Check\nIncorporates logic from single-case counterfactuals to test minimal sufficiency.\nFor D3-Q3 (Traceability/Resources): checks if resource X (BPIN code) were removed,\nwould the mechanism (Product) still execute? Only boosts budget traceability score\nif allocation is tied to a specific project.",
          "line_number": 1646,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_process_financial_table",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "_process_financial_table(self, table, nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of FinancialAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Process a single financial table",
          "line_number": 1676,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_parse_amount",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "_parse_amount(self, value)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of FinancialAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Parse monetary amount from various formats",
          "line_number": 1747,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_match_program_to_node",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "_match_program_to_node(self, program_id, nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of FinancialAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Match program ID to existing node using fuzzy matching\n\nEnhanced for D1-Q3 / D3-Q3 Financial Traceability:\n- Implements confidence penalty if fuzzy match ratio < 100\n- Reduces node.financial_allocation confidence by 15% for imperfect matches\n- Tracks match quality for overall financial traceability scoring",
          "line_number": 1762,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_perform_counterfactual_budget_check",
          "class": "FinancialAuditor",
          "file": "dereck_beach.py",
          "signature": "_perform_counterfactual_budget_check(self, nodes, graph)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of FinancialAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Harmonic Front 3 - Enhancement 5: Counterfactual Sufficiency Test for D3-Q3\n\nTests minimal sufficiency: if resource X (BPIN code) were removed, would the\nmechanism (Product) still execute? Only boosts budget traceability score if\nallocation is tied to a specific project.\n\nFor D3-Q3 (Traceability/Resources): ensures funding is necessary for the mechanism\nand prevents false positives from generic or disconnected budget entries.",
          "line_number": 1817,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1912,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "audit_evidence_traceability",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "audit_evidence_traceability(self, nodes)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Audit evidence traceability for all nodes\n\nEnhanced with D3-Q1 Ficha Técnica validation:\n- Cross-checks baseline/target against extracted quantitative_claims\n- Verifies DNP INDICATOR_STRUCTURE compliance for producto nodes\n- Scores 'Excelente' only if ≥80% of productos pass full audit",
          "line_number": 1919,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "audit_sequence_logic",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "audit_sequence_logic(self, graph)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Audit logical sequence of activities",
          "line_number": 2049,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "bayesian_counterfactual_audit",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "bayesian_counterfactual_audit(self, nodes, graph, historical_data, pdet_alignment)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "numpy",
            "scipy",
            "statistical libraries"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "AGUJA III: El Auditor Contrafactual Bayesiano\nPerform counterfactual audit using Bayesian causal reasoning\n\nHarmonic Front 3: Enhanced to consume pdet_alignment scores for D4-Q5 and D5-Q4 integration",
          "line_number": 2089,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "_build_normative_dag",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_build_normative_dag(self)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "networkx",
            "graph structures"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Build normative DAG of expected relationships in well-formed plans",
          "line_number": 2137,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_get_default_historical_priors",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_get_default_historical_priors(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Get default historical priors if no data is available",
          "line_number": 2160,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_audit_direct_evidence",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_audit_direct_evidence(self, nodes, scm_dag, historical_data)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Layer 1: Audit direct evidence of required components\n\nEnhanced with highly specific Bayesian priors for rare evidence items.\nExample: D2-Q4 risk matrix, D5-Q5 unwanted effects are rare in poor PDMs.",
          "line_number": 2176,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_audit_causal_implications",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_audit_causal_implications(self, nodes, graph, direct_evidence)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Layer 2: Audit causal implications of omissions",
          "line_number": 2278,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_audit_systemic_risk",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_audit_systemic_risk(self, nodes, graph, direct_evidence, causal_implications, pdet_alignment)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "AUDIT POINT 2.3: Policy Alignment Dual Constraint\nLayer 3: Calculate systemic risk from accumulated omissions\n\nHarmonic Front 3 - Enhancement 1: Alignment and Systemic Risk Linkage\nIncorporates Policy Alignment scores (PND, ODS, RRI) as variable in systemic risk.\n\nFor D5-Q4 (Riesgos Sistémicos) and D4-Q5 (Alineación):\n- If pdet_alignment ≤ 0.60, applies 1.2× multiplier to risk_score\n- Excelente on D5-Q4 requires risk_score < 0.10\n\nImplements dual constraints integrating macro-micro causality per Lieberman 2015.",
          "line_number": 2331,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_optimal_remediations",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_generate_optimal_remediations(self, direct_evidence, causal_implications, systemic_risk)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Generate prioritized remediation recommendations",
          "line_number": 2449,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_remediation_text",
          "class": "OperationalizationAuditor",
          "file": "dereck_beach.py",
          "signature": "_get_remediation_text(self, omission, node_id)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of OperationalizationAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Get specific remediation text for an omission",
          "line_number": 2497,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config, nlp_model)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 2528,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_log_refactored_components",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_log_refactored_components(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Log status of refactored Bayesian components (F1.2)",
          "line_number": 2569,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "infer_mechanisms",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "infer_mechanisms(self, nodes, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Infer latent causal mechanisms using hierarchical Bayesian modeling\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Tracks mean mechanism_type uncertainty for quality criteria\n- Reports uncertainty reduction metrics",
          "line_number": 2580,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_infer_single_mechanism",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_infer_single_mechanism(self, node, text, all_nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Infer mechanism for a single product node",
          "line_number": 2619,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_observations",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_extract_observations(self, node, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract textual observations related to the mechanism",
          "line_number": 2661,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_infer_mechanism_type",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_infer_mechanism_type(self, observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Infer mechanism type using Bayesian updating",
          "line_number": 2703,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_infer_activity_sequence",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_infer_activity_sequence(self, observations, mechanism_type_posterior)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Infer activity sequence parameters",
          "line_number": 2741,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_coherence_factor",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_calculate_coherence_factor(self, node, observations, all_nodes)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate mechanism coherence score",
          "line_number": 2769,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_test_sufficiency",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_test_sufficiency(self, node, observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Test if mechanism is sufficient to produce the outcome",
          "line_number": 2810,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_test_necessity",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_test_necessity(self, node, observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "AUDIT POINT 2.2: Mechanism Necessity Hoop Test\n\nTest if mechanism is necessary by checking documented components:\n- Entity (responsable)\n- Activity (verb lemma sequence)\n- Budget (presupuesto asignado)\n\nImplements Beach 2017 Hoop Tests for necessity verification.\nPer Falleti & Lynch 2009, Bayesian-deterministic hybrid boosts mechanism depth.\n\nReturns:\n    Dict with 'is_necessary', 'missing_components', and remediation text",
          "line_number": 2838,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_necessity_remediation",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_generate_necessity_remediation(self, node_id, missing_components)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Generate remediation text for failed necessity test",
          "line_number": 2922,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_quantify_uncertainty",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_quantify_uncertainty(self, mechanism_type_posterior, sequence_posterior, coherence_score)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Quantify epistemic uncertainty",
          "line_number": 2941,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_detect_gaps",
          "class": "BayesianMechanismInference",
          "file": "dereck_beach.py",
          "signature": "_detect_gaps(self, node, observations, uncertainty)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianMechanismInference must be initialized"
          ],
          "risks": [],
          "docstring": "Detect documentation gaps based on uncertainty",
          "line_number": 2975,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "CausalInferenceSetup",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 3022,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "classify_goal_dynamics",
          "class": "CausalInferenceSetup",
          "file": "dereck_beach.py",
          "signature": "classify_goal_dynamics(self, nodes)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalInferenceSetup must be initialized"
          ],
          "risks": [],
          "docstring": "Classify dynamics for each goal",
          "line_number": 3029,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "assign_probative_value",
          "class": "CausalInferenceSetup",
          "file": "dereck_beach.py",
          "signature": "assign_probative_value(self, nodes)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalInferenceSetup must be initialized"
          ],
          "risks": [],
          "docstring": "Assign probative test types to nodes",
          "line_number": 3040,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "identify_failure_points",
          "class": "CausalInferenceSetup",
          "file": "dereck_beach.py",
          "signature": "identify_failure_points(self, graph, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CausalInferenceSetup must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Identify single points of failure in causal chain\n\nHarmonic Front 3 - Enhancement 2: Contextual Failure Point Detection\nExpands risk_pattern to explicitly include localized contextual factors from rubrics:\n- restricciones territoriales\n- patrones culturales machistas\n- limitación normativa\n\nFor D6-Q5 (Enfoque Diferencial/Restricciones): Excelente requires ≥3 distinct\ncontextual factors correctly mapped to nodes, satisfying enfoque_diferencial\nand analisis_contextual criteria.",
          "line_number": 3099,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config, output_dir)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 3201,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "generate_causal_diagram",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "generate_causal_diagram(self, graph, policy_code)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportingEngine must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Generate causal diagram visualization",
          "line_number": 3207,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "generate_accountability_matrix",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "generate_accountability_matrix(self, graph, policy_code)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportingEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Generate accountability matrix in Markdown",
          "line_number": 3294,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_confidence_report",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "generate_confidence_report(self, nodes, graph, causal_chains, audit_results, financial_auditor, sequence_warnings, policy_code)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportingEngine must be initialized"
          ],
          "risks": [
            "High computational complexity",
            "Multiple parameters increase error surface"
          ],
          "docstring": "Generate extraction confidence report",
          "line_number": 3353,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "_calculate_quality_score",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "_calculate_quality_score(self, traceability, financial, logic, ea)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportingEngine must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate overall quality score (0-100)",
          "line_number": 3443,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_causal_model_json",
          "class": "ReportingEngine",
          "file": "dereck_beach.py",
          "signature": "generate_causal_model_json(self, graph, nodes, policy_code)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportingEngine must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Generate structured JSON export of causal model",
          "line_number": 3453,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "__init__",
          "class": "CDAFFramework",
          "file": "dereck_beach.py",
          "signature": "__init__(self, config_path, output_dir, log_level)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 3505,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "process_document",
          "class": "CDAFFramework",
          "file": "dereck_beach.py",
          "signature": "process_document(self, pdf_path, policy_code)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFFramework must be initialized"
          ],
          "risks": [],
          "docstring": "Main processing pipeline",
          "line_number": 3576,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_feedback_from_audit",
          "class": "CDAFFramework",
          "file": "dereck_beach.py",
          "signature": "_extract_feedback_from_audit(self, inferred_mechanisms, counterfactual_audit, audit_results)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFFramework must be initialized"
          ],
          "risks": [],
          "docstring": "Extract feedback data from audit results for self-reflective prior updating\n\nThis implements the frontier paradigm of learning from audit results\nto improve future inference accuracy.\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Reduces mechanism_type_priors for mechanisms with implementation_failure flags\n- Tracks necessity/sufficiency test failures\n- Penalizes \"miracle\" mechanisms that fail counterfactual tests",
          "line_number": 3687,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_validate_dnp_compliance",
          "class": "CDAFFramework",
          "file": "dereck_beach.py",
          "signature": "_validate_dnp_compliance(self, nodes, graph, policy_code)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFFramework must be initialized"
          ],
          "risks": [],
          "docstring": "Validate DNP compliance for all nodes/projects\nGenerates DNP compliance report",
          "line_number": 3785,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_dnp_report",
          "class": "CDAFFramework",
          "file": "dereck_beach.py",
          "signature": "_generate_dnp_report(self, dnp_results, policy_code)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of CDAFFramework must be initialized"
          ],
          "risks": [],
          "docstring": "Generate comprehensive DNP compliance report",
          "line_number": 3861,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_bayes_factor",
          "class": "BayesFactorTable",
          "file": "dereck_beach.py",
          "signature": "get_bayes_factor(cls, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Obtiene BF medio para tipo de test",
          "line_number": 3984,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_version",
          "class": "BayesFactorTable",
          "file": "dereck_beach.py",
          "signature": "get_version(cls)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Version de tabla BF para trazabilidad",
          "line_number": 3992,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "__init__(self, calibration_params)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 4018,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "calculate_likelihood_adaptativo",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "calculate_likelihood_adaptativo(self, evidence_dict, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT I-1: Calcula likelihood adaptativo con BF y dominios\n\nArgs:\n    evidence_dict: Evidencia por caso {semantic, temporal, financial, structural}\n    test_type: Tipo de test evidencial (straw, hoop, smoking, doubly)\n\nReturns:\n    Dict con p_mechanism, BF_used, domain_weights, triangulation_bonus, etc.",
          "line_number": 4036,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_adjust_domain_weights",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "_adjust_domain_weights(self, domain_scores)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "Ajusta pesos si falta dominio: baja a 0 y reparte",
          "line_number": 4103,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "sensitivity_analysis",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "sensitivity_analysis(self, evidence_dict, test_type, perturbation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT I-2: Sensibilidad, OOD y ablation evidencial\n\nPerturba cada componente ±10% y reporta ∂p/∂component top-3.\nEjecuta ablaciones: sólo textual, sólo financiero, sólo estructural.\n\nCRITERIA:\n- |delta_p_sensitivity|_max ≤ 0.15\n- sign_concordance ≥ 2/3\n- OOD_drop ≤ 0.10",
          "line_number": 4130,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_perturb_evidence",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "_perturb_evidence(self, evidence_dict, domain, perturbation)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "Perturba un dominio específico",
          "line_number": 4217,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_add_ood_noise",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "_add_ood_noise(self, evidence_dict)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "Genera set OOD con ruido semántico y tablas malformadas",
          "line_number": 4231,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_traceability_record",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "generate_traceability_record(self, evidence_dict, test_type, result, seed)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT I-3: Trazabilidad y reproducibilidad\n\nCon semilla fija, guarda bf_table_version, weights_version,\nsnippets textuales con offsets, campos financieros usados.\n\nMETRICS:\n- Re-ejecución con misma semilla produce hash_result idéntico\n- trace_completeness ≥ 0.95",
          "line_number": 4244,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_quality_criteria",
          "class": "AdaptivePriorCalculator",
          "file": "dereck_beach.py",
          "signature": "validate_quality_criteria(self, validation_samples)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdaptivePriorCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "Valida criterios de calidad en conjunto de validación sintética\n\nQUALITY CRITERIA:\n- BrierScore ≤ 0.20\n- ACE ∈ [−0.02, 0.02]\n- Cobertura CI95% ∈ [92%, 98%]\n- Monotonicidad verificada",
          "line_number": 4308,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "__init__(self, mechanism_priors)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 4431,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "infer_mechanism_posterior",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "infer_mechanism_posterior(self, observations, n_iter, burn_in, n_chains)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT II-1: Inferencia jerárquica con MCMC\n\nEstima posterior(mechanism_type, activity_sequence | obs) usando MCMC.\n\nArgs:\n    observations: Dict con {verbos, co_ocurrencias, coherence, structural_signals}\n    n_iter: Iteraciones MCMC (≥500)\n    burn_in: Burn-in iterations (≥100)\n    n_chains: Número de cadenas para R-hat (≥2)\n\nReturns:\n    Dict con type_posterior, sequence_mode, coherence_score, entropy, CI95, R-hat, ESS",
          "line_number": 4451,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_run_mcmc_chain",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_run_mcmc_chain(self, observations, n_iter, burn_in, seed)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Ejecuta una cadena MCMC con Metropolis-Hastings",
          "line_number": 4562,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_likelihood",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_calculate_likelihood(self, mechanism_type, observations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula likelihood de observations dado mechanism_type",
          "line_number": 4615,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_mode_sequence",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_get_mode_sequence(self, samples)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Obtiene secuencia modal (tipo más frecuente)",
          "line_number": 4643,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_r_hat",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_calculate_r_hat(self, chains)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula Gelman-Rubin R-hat para diagnóstico de convergencia",
          "line_number": 4654,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_ess",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_calculate_ess(self, samples)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula Effective Sample Size (simplificado)",
          "line_number": 4688,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "posterior_predictive_check",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "posterior_predictive_check(self, posterior_samples, observed_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT II-2: Posterior Predictive Checks + Ablation\n\nGenera datos simulados desde posterior y compara con observados.\nRealiza ablation de pasos de secuencia.\n\nArgs:\n    posterior_samples: Samples del posterior MCMC\n    observed_data: Datos observados reales\n\nReturns:\n    Dict con ppd_p_value, distance_metric, ablation_curve, criteria_met",
          "line_number": 4713,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_ablation_analysis",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_ablation_analysis(self, posterior_samples, observed_data)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Mide caída en coherence al quitar pasos de secuencia",
          "line_number": 4786,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "verify_conditional_independence",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "verify_conditional_independence(self, dag, independence_tests)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT II-3: Independencias y parsimonia\n\nVerifica d-separaciones implicadas por el DAG.\nCalcula ΔWAIC entre modelo jerárquico vs. nulo.\n\nArgs:\n    dag: NetworkX DiGraph del modelo causal\n    independence_tests: Lista de tuplas (X, Y, Z) para test X ⊥ Y | Z\n\nReturns:\n    Dict con independence_tests, delta_waic, model_preference, criteria_met",
          "line_number": 4805,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_independence_tests",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_generate_independence_tests(self, dag, n_tests)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Genera tests de independencia automáticamente desde DAG",
          "line_number": 4886,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_waic_difference",
          "class": "HierarchicalGenerativeModel",
          "file": "dereck_beach.py",
          "signature": "_calculate_waic_difference(self, dag)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of HierarchicalGenerativeModel must be initialized"
          ],
          "risks": [],
          "docstring": "Calcula ΔWAIC = WAIC_hierarchical - WAIC_null (simplificado)\n\nEn producción: usar arviz.waic() con trace real de PyMC/Stan",
          "line_number": 4912,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 4958,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "construct_scm",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "construct_scm(self, dag, structural_equations)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT III-1: Construcción de SCM\n\nConstruye SCM = {DAG, f_i} desde grafo y ecuaciones estructurales.\n\nArgs:\n    dag: NetworkX DiGraph (debe ser acíclico)\n    structural_equations: Dict {node: function} para f_i\n\nReturns:\n    SCM con DAG validado y funciones estructurales\n\nRaises:\n    ValueError: Si DAG no es acíclico",
          "line_number": 4962,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_create_default_equations",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "_create_default_equations(self, dag)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Crea ecuaciones estructurales lineales por defecto",
          "line_number": 5006,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "counterfactual_query",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "counterfactual_query(self, intervention, target, evidence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT III-1: Queries gemelas (omission, sufficiency, necessity)\n\nEvalúa:\n- Factual: P(Y | evidence)\n- Counterfactual: P(Y | do(X=x), evidence)\n- Causal effect, sufficiency, necessity\n\nArgs:\n    intervention: {nodo: valor} para do(.) operation\n    target: Nodo objetivo Y\n    evidence: Evidencia observada (opcional)\n\nReturns:\n    Dict con p_factual, p_counterfactual, causal_effect, is_sufficient, is_necessary",
          "line_number": 5028,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_evaluate_factual",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "_evaluate_factual(self, target, evidence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Evalúa P(target | evidence) propagando hacia adelante en DAG",
          "line_number": 5101,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_evaluate_counterfactual",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "_evaluate_counterfactual(self, target, intervention, evidence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Evalúa P(target | do(intervention), evidence) con DAG mutilado",
          "line_number": 5143,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_test_effect_stability",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "_test_effect_stability(self, intervention, target, evidence, n_perturbations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "Testa estabilidad al variar priors/ecuaciones ±10%",
          "line_number": 5180,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "aggregate_risk_and_prioritize",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "aggregate_risk_and_prioritize(self, omission_score, insufficiency_score, unnecessity_score, causal_effect, feasibility, cost)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [
            "High computational complexity",
            "Multiple parameters increase error surface"
          ],
          "docstring": "PROMPT III-2: Riesgo sistémico y priorización con incertidumbre\n\nFórmulas:\n- risk = 0.50·omission + 0.35·insufficiency + 0.15·unnecessity\n- priority = |effect|·feasibility/(cost+ε)·(1−uncertainty)\n\nArgs:\n    omission_score: Riesgo de omisión de mecanismo [0,1]\n    insufficiency_score: Insuficiencia del mecanismo [0,1]\n    unnecessity_score: Mecanismo innecesario [0,1]\n    causal_effect: Efecto causal estimado\n    feasibility: Factibilidad de intervención [0,1]\n    cost: Costo relativo (>0)\n\nReturns:\n    Dict con risk_score, success_probability, priority, recommendations",
          "line_number": 5217,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "refutation_and_sanity_checks",
          "class": "BayesianCounterfactualAuditor",
          "file": "dereck_beach.py",
          "signature": "refutation_and_sanity_checks(self, dag, target, treatment, confounders)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianCounterfactualAuditor must be initialized"
          ],
          "risks": [],
          "docstring": "PROMPT III-3: Refutación, negativos y cordura do(.)\n\nEjecuta:\n1. Controles negativos: nodos irrelevantes → |efecto| ≤ 0.05\n2. Pruebas placebo: permuta edges no causales\n3. Sanity checks: añadir cofactores no reduce P(Y|do(X=1))\n\nArgs:\n    dag: Grafo causal\n    target: Nodo objetivo Y\n    treatment: Nodo de tratamiento X\n    confounders: Lista de cofactores\n\nReturns:\n    Dict con negative_controls, placebo_effect, sanity_violations, recommendation",
          "line_number": 5328,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize producer",
          "line_number": 5558,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "classify_test_type",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "classify_test_type(self, necessity, sufficiency)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify evidential test type based on necessity and sufficiency",
          "line_number": 5567,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "apply_test_logic",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "apply_test_logic(self, test_type, evidence_found, prior, bayes_factor)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Apply Beach test-specific logic to Bayesian updating",
          "line_number": 5571,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_hoop_test",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_hoop_test(self, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if test is hoop test",
          "line_number": 5583,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_smoking_gun",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_smoking_gun(self, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if test is smoking gun",
          "line_number": 5587,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_doubly_decisive",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_doubly_decisive(self, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if test is doubly decisive",
          "line_number": 5591,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_straw_in_wind",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_straw_in_wind(self, test_type)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if test is straw in wind",
          "line_number": 5595,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "create_hierarchical_model",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "create_hierarchical_model(self, mechanism_priors)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Create hierarchical generative model",
          "line_number": 5603,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "infer_mechanism_posterior",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "infer_mechanism_posterior(self, model, observations, n_iter, burn_in, n_chains)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Infer mechanism posterior using MCMC",
          "line_number": 5610,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 95.0
        },
        {
          "method_name": "get_type_posterior",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_type_posterior(self, inference)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract type posterior from inference",
          "line_number": 5623,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_sequence_mode",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_sequence_mode(self, inference)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract sequence mode from inference",
          "line_number": 5627,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_coherence_score",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_coherence_score(self, inference)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract coherence score from inference",
          "line_number": 5631,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_r_hat",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_r_hat(self, inference)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract R-hat convergence diagnostic",
          "line_number": 5635,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_ess",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_ess(self, inference)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract effective sample size",
          "line_number": 5639,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_inference_uncertain",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_inference_uncertain(self, inference)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Check if inference has high uncertainty",
          "line_number": 5643,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "posterior_predictive_check",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "posterior_predictive_check(self, model, posterior_samples, observed_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Run posterior predictive checks",
          "line_number": 5651,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_ppd_p_value",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_ppd_p_value(self, ppc)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract posterior predictive p-value",
          "line_number": 5660,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_ablation_curve",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_ablation_curve(self, ppc)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract ablation curve from PPC",
          "line_number": 5664,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_ppc_recommendation",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_ppc_recommendation(self, ppc)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract recommendation from PPC",
          "line_number": 5668,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "verify_conditional_independence",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "verify_conditional_independence(self, model, dag, independence_tests)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Verify conditional independencies in DAG",
          "line_number": 5676,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_independence_tests",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_independence_tests(self, verification)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract independence tests from verification",
          "line_number": 5685,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_delta_waic",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_delta_waic(self, verification)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract delta WAIC from verification",
          "line_number": 5689,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_model_preference",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_model_preference(self, verification)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract model preference from verification",
          "line_number": 5693,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "create_auditor",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "create_auditor(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Create Bayesian counterfactual auditor",
          "line_number": 5701,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "construct_scm",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "construct_scm(self, auditor, dag, structural_equations)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Construct structural causal model",
          "line_number": 5705,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "counterfactual_query",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "counterfactual_query(self, auditor, intervention, target, evidence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Execute counterfactual query",
          "line_number": 5714,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_causal_effect",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_causal_effect(self, query)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Extract causal effect from query",
          "line_number": 5724,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "is_sufficient",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_sufficient(self, query)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if mechanism is sufficient",
          "line_number": 5728,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_necessary",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_necessary(self, query)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if mechanism is necessary",
          "line_number": 5732,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_effect_stable",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "is_effect_stable(self, query)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if effect is stable",
          "line_number": 5736,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "aggregate_risk",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "aggregate_risk(self, auditor, omission_score, insufficiency_score, unnecessity_score, causal_effect, feasibility, cost)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [
            "High computational complexity",
            "Multiple parameters increase error surface"
          ],
          "docstring": "Aggregate risk and calculate priority",
          "line_number": 5744,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 80.0
        },
        {
          "method_name": "get_risk_score",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_risk_score(self, aggregation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract risk score from aggregation",
          "line_number": 5764,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_success_probability",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_success_probability(self, aggregation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract success probability from aggregation",
          "line_number": 5768,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_priority",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_priority(self, aggregation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract priority from aggregation",
          "line_number": 5772,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_recommendations",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_recommendations(self, aggregation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract recommendations from aggregation",
          "line_number": 5776,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "refutation_checks",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "refutation_checks(self, auditor, dag, target, treatment, confounders)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Execute refutation and sanity checks",
          "line_number": 5784,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 95.0
        },
        {
          "method_name": "get_negative_controls",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_negative_controls(self, refutation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract negative controls from refutation",
          "line_number": 5797,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_placebo_effect",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_placebo_effect(self, refutation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract placebo effect from refutation",
          "line_number": 5801,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_sanity_violations",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_sanity_violations(self, refutation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract sanity violations from refutation",
          "line_number": 5805,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "all_checks_passed",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "all_checks_passed(self, refutation)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if all refutation checks passed",
          "line_number": 5809,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_refutation_recommendation",
          "class": "DerekBeachProducer",
          "file": "dereck_beach.py",
          "signature": "get_refutation_recommendation(self, refutation)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of DerekBeachProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract recommendation from refutation",
          "line_number": 5813,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "policy_processor.py": {
      "method_count": 41,
      "methods": [
        {
          "method_name": "from_legacy",
          "class": "ProcessorConfig",
          "file": "policy_processor.py",
          "signature": "from_legacy(cls)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Construct configuration from legacy parameter names.",
          "line_number": 350,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate",
          "class": "ProcessorConfig",
          "file": "policy_processor.py",
          "signature": "validate(self)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ProcessorConfig must be initialized"
          ],
          "risks": [],
          "docstring": "Validate configuration parameters.",
          "line_number": 358,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BayesianEvidenceScorer",
          "file": "policy_processor.py",
          "signature": "__init__(self, prior_confidence, entropy_weight)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 394,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "compute_evidence_score",
          "class": "BayesianEvidenceScorer",
          "file": "policy_processor.py",
          "signature": "compute_evidence_score(self, matches, total_corpus_size, pattern_specificity)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianEvidenceScorer must be initialized"
          ],
          "risks": [],
          "docstring": "Compute probabilistic confidence score for evidence matches.\n\nArgs:\n    matches: List of matched text segments\n    total_corpus_size: Total document size in characters\n    pattern_specificity: Pattern discrimination power [0,1]\n\nReturns:\n    Calibrated confidence score in [0, 1]",
          "line_number": 399,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_shannon_entropy",
          "class": "BayesianEvidenceScorer",
          "file": "policy_processor.py",
          "signature": "_calculate_shannon_entropy(values)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Calculate normalized Shannon entropy for value distribution.",
          "line_number": 440,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PolicyTextProcessor",
          "file": "policy_processor.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 466,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "normalize_unicode",
          "class": "PolicyTextProcessor",
          "file": "policy_processor.py",
          "signature": "normalize_unicode(self, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyTextProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Apply canonical Unicode normalization (NFC/NFKC).",
          "line_number": 473,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "segment_into_sentences",
          "class": "PolicyTextProcessor",
          "file": "policy_processor.py",
          "signature": "segment_into_sentences(self, text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyTextProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Segment text into sentences with context-aware boundary detection.\nHandles abbreviations, numerical lists, and Colombian naming conventions.",
          "line_number": 477,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "extract_contextual_window",
          "class": "PolicyTextProcessor",
          "file": "policy_processor.py",
          "signature": "extract_contextual_window(self, text, match_position, window_size)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PolicyTextProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract semantically coherent context window around a match.",
          "line_number": 503,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "compile_pattern",
          "class": "PolicyTextProcessor",
          "file": "policy_processor.py",
          "signature": "compile_pattern(self, pattern_str)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyTextProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Cache and compile regex patterns for performance.",
          "line_number": 519,
          "decorators": [
            "<ast.Call object at 0x7f1ee9eaaf10>"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "to_dict",
          "class": "EvidenceBundle",
          "file": "policy_processor.py",
          "signature": "to_dict(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of EvidenceBundle must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 539,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "__init__",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "__init__(self, config, questionnaire_path)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 559,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_load_questionnaire",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_load_questionnaire(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Load and validate DECALOGO questionnaire structure.",
          "line_number": 603,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compile_pattern_registry",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_compile_pattern_registry(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Compile all causal patterns into efficient regex objects.",
          "line_number": 617,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_build_point_patterns",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_build_point_patterns(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Extract and compile patterns for each policy point from questionnaire.",
          "line_number": 628,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "process",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "process(self, raw_text)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Execute comprehensive policy plan analysis.\n\nArgs:\n    raw_text: Sanitized policy document text\n\nReturns:\n    Structured analysis results with evidence bundles and confidence scores",
          "line_number": 657,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_match_patterns_in_sentences",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_match_patterns_in_sentences(self, compiled_patterns, relevant_sentences)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Execute pattern matching across relevant sentences and collect matches with positions.\n\nArgs:\n    compiled_patterns: List of compiled regex patterns to match\n    relevant_sentences: Filtered sentences to search within\n    \nReturns:\n    Tuple of (matched_strings, match_positions)",
          "line_number": 749,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_evidence_confidence",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_compute_evidence_confidence(self, matches, text_length, pattern_specificity)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate confidence score for evidence based on pattern matches and contextual factors.\n\nArgs:\n    matches: List of matched pattern strings\n    text_length: Total length of the document text\n    pattern_specificity: Specificity coefficient for pattern weighting\n    \nReturns:\n    Computed confidence score",
          "line_number": 773,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_construct_evidence_bundle",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_construct_evidence_bundle(self, dimension, category, matches, positions, confidence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Assemble evidence bundle from matched patterns and computed confidence.\n\nArgs:\n    dimension: Causal dimension classification\n    category: Specific category within dimension\n    matches: List of matched pattern strings\n    positions: List of match positions in text\n    confidence: Computed confidence score\n    \nReturns:\n    Serialized evidence bundle dictionary",
          "line_number": 792,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_run_contradiction_analysis",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_run_contradiction_analysis(self, text, metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Execute contradiction and temporal diagnostics across all dimensions.",
          "line_number": 822,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_quality_score",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_calculate_quality_score(self, dimension_analysis, contradiction_bundle, performance_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Aggregate key indicators into a structured QualityScore dataclass.",
          "line_number": 930,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_point_evidence",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_extract_point_evidence(self, text, sentences, point_code)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract evidence for a specific policy point across all dimensions.",
          "line_number": 998,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_analyze_causal_dimensions",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_analyze_causal_dimensions(self, text, sentences)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Perform global analysis of causal dimensions across entire document.",
          "line_number": 1037,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_metadata",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_extract_metadata(text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Extract key metadata from policy document header.",
          "line_number": 1077,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_compute_avg_confidence",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_compute_avg_confidence(dimension_analysis)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [],
          "prerequisites": [],
          "risks": [],
          "docstring": "Calculate average confidence across all dimensions.",
          "line_number": 1108,
          "decorators": [
            "staticmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_empty_result",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "_empty_result(self)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Return structure for failed/empty processing.",
          "line_number": 1117,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_results",
          "class": "IndustrialPolicyProcessor",
          "file": "policy_processor.py",
          "signature": "export_results(self, results, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of IndustrialPolicyProcessor must be initialized"
          ],
          "risks": [],
          "docstring": "Export analysis results to JSON with formatted output.",
          "line_number": 1133,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "AdvancedTextSanitizer",
          "file": "policy_processor.py",
          "signature": "__init__(self, config)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1156,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "sanitize",
          "class": "AdvancedTextSanitizer",
          "file": "policy_processor.py",
          "signature": "sanitize(self, raw_text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedTextSanitizer must be initialized"
          ],
          "risks": [],
          "docstring": "Execute comprehensive text sanitization pipeline.\n\nPipeline stages:\n1. Unicode normalization (NFC)\n2. Structure element protection\n3. Whitespace normalization\n4. Special character handling\n5. Encoding validation",
          "line_number": 1165,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_protect_structure",
          "class": "AdvancedTextSanitizer",
          "file": "policy_processor.py",
          "signature": "_protect_structure(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedTextSanitizer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Mark structural elements for protection during sanitization.",
          "line_number": 1202,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_restore_structure",
          "class": "AdvancedTextSanitizer",
          "file": "policy_processor.py",
          "signature": "_restore_structure(self, text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of AdvancedTextSanitizer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Remove protection markers after sanitization.",
          "line_number": 1233,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "read_text",
          "class": "ResilientFileHandler",
          "file": "policy_processor.py",
          "signature": "read_text(cls, file_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Read text file with automatic encoding detection and fallback cascade.\n\nArgs:\n    file_path: Path to input file\n\nReturns:\n    Decoded text content\n\nRaises:\n    IOError: If file cannot be read with any supported encoding",
          "line_number": 1255,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "write_text",
          "class": "ResilientFileHandler",
          "file": "policy_processor.py",
          "signature": "write_text(cls, content, file_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Write text content with UTF-8 encoding and directory creation.",
          "line_number": 1289,
          "decorators": [
            "classmethod"
          ],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": false
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "PolicyAnalysisPipeline",
          "file": "policy_processor.py",
          "signature": "__init__(self, config, questionnaire_path)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 1310,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "analyze_file",
          "class": "PolicyAnalysisPipeline",
          "file": "policy_processor.py",
          "signature": "analyze_file(self, input_path, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisPipeline must be initialized"
          ],
          "risks": [],
          "docstring": "Execute complete analysis pipeline on a policy document file.\n\nArgs:\n    input_path: Path to input policy document (text format)\n    output_path: Optional path for JSON results export\n\nReturns:\n    Complete analysis results dictionary",
          "line_number": 1340,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": true,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "analyze_text",
          "class": "PolicyAnalysisPipeline",
          "file": "policy_processor.py",
          "signature": "analyze_text(self, raw_text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of PolicyAnalysisPipeline must be initialized"
          ],
          "risks": [],
          "docstring": "Execute analysis pipeline on raw text input.\n\nArgs:\n    raw_text: Raw policy document text\n\nReturns:\n    Complete analysis results dictionary",
          "line_number": 1391,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "BayesianConfidenceCalculator",
          "file": "policy_processor.py",
          "signature": "__init__(self)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 54,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "calculate_posterior",
          "class": "BayesianConfidenceCalculator",
          "file": "policy_processor.py",
          "signature": "calculate_posterior(self, evidence_strength, observations, domain_weight)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of BayesianConfidenceCalculator must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 58,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "verify_temporal_consistency",
          "class": "TemporalLogicVerifier",
          "file": "policy_processor.py",
          "signature": "verify_temporal_consistency(self, statements)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of TemporalLogicVerifier must be initialized"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 68,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "detect",
          "class": "_FallbackContradictionDetector",
          "file": "policy_processor.py",
          "signature": "detect(self, text, plan_name, dimension)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of _FallbackContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 72,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_policy_statements",
          "class": "_FallbackContradictionDetector",
          "file": "policy_processor.py",
          "signature": "_extract_policy_statements(self, text, dimension)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of _FallbackContradictionDetector must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "No documentation available",
          "line_number": 89,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    },
    "report_assembly.py": {
      "method_count": 125,
      "methods": [
        {
          "method_name": "__init__",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "__init__(self, dimension_descriptions, cluster_weights, cluster_policy_weights, causal_thresholds)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize report assembler with rubric definitions",
          "line_number": 141,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_micro_answer",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "generate_micro_answer(self, question_spec, execution_results, plan_text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate MICRO-level answer for a single question\n\nArgs:\n    question_spec: Question specification with scoring modality\n    execution_results: Dict of adapter execution results\n    plan_text: Original plan document text\n    \nReturns:\n    MicroLevelAnswer with complete analysis",
          "line_number": 200,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_scoring_modality",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_apply_scoring_modality(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Apply scoring modality (TYPE_A, TYPE_B, etc.) to calculate question score\n\nReturns:\n    (score, elements_found, pattern_matches, causal_correction_metadata)",
          "line_number": 307,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_causal_correction",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_apply_causal_correction(self, question_spec, base_score, execution_results)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Adjust base score using causal coherence signals when required.",
          "line_number": 380,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_causal_signals",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_causal_signals(self, execution_results)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Collect numeric causal signals present in execution results.",
          "line_number": 439,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_extract_causal_flags",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_causal_flags(self, execution_results)",
          "complexity": "HIGH",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Identify boolean causal flags signalling structural issues.",
          "line_number": 474,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 90.0
        },
        {
          "method_name": "_score_type_a",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_a(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_A: Binary presence/absence scoring (from rubric_scoring.json)\n\nFORMULA: Score = (elements_found / 4) * 3\n- Expected elements: 4 (as defined in rubric TYPE_A)\n- Each element worth: 0.75 points\n- Max score: 3.0 points\n\nCONVERSION TABLE (from rubric):\n0 elements → 0.00 points\n1 element  → 0.75 points\n2 elements → 1.50 points\n3 elements → 2.25 points\n4 elements → 3.00 points\n\nPRECONDITIONS:\n- question_spec must have expected_elements list\n- execution_results must be non-empty dict\n- plan_text must be non-empty string",
          "line_number": 505,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_type_b",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_b(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_B: Weighted sum of multiple elements\n\nDifferent elements have different weights",
          "line_number": 564,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_type_c",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_c(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_C: Quality assessment with rubric\n\nUses confidence scores from adapters to assess quality",
          "line_number": 602,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_type_d",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_d(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_D: Numerical threshold matching\n\nChecks if numerical values meet specified thresholds",
          "line_number": 631,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_type_e",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_e(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_E: Logical rule-based scoring (from rubric_scoring.json)\n\nApplies if-then-else logic based on custom rules\nUses custom logic defined per question\n\nPRECONDITIONS:\n- question_spec must have validation_rules with logical conditions\n- execution_results must be non-empty dict",
          "line_number": 667,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_type_f",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_type_f(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "TYPE_F: Semantic analysis with similarity matching (from rubric_scoring.json)\n\nUses semantic matching with cosine similarity\nApplies thresholds based on coverage ratio\n\nFORMULA: f(coverage_ratio) with thresholds\n- similarity_threshold: 0.6 (default from rubric)\n\nPRECONDITIONS:\n- question_spec must have expected_elements or search_patterns\n- execution_results must contain semantic analysis results",
          "line_number": 738,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_evaluate_condition",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_evaluate_condition(self, condition, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Evaluate a logical condition for TYPE_E scoring\n\nSupports:\n- \"contains\": check if text contains pattern\n- \"threshold\": check if value meets threshold\n- \"all_of\": all subconditions must be true\n- \"any_of\": at least one subcondition must be true",
          "line_number": 818,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_default",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_default(self, question_spec, execution_results)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Default scoring: Confidence-weighted average",
          "line_number": 882,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_numerical_value",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_numerical_value(self, metric, execution_results)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Extract numerical value for a metric from execution results",
          "line_number": 906,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_pattern_matches",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_pattern_matches(self, question_spec, execution_results, plan_text)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Extract pattern matches from execution results",
          "line_number": 921,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_score_to_qualitative_question",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_score_to_qualitative_question(self, score)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Map quantitative score (0-3) to qualitative level\n\nUses question_rubric thresholds with >= comparisons from high to low.\nThis ensures highest scores are matched first, preventing incorrect\nassignment to lower rubrics.",
          "line_number": 936,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_evidence_excerpts",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_evidence_excerpts(self, question_spec, execution_results, elements_found, plan_text, max_excerpts)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Extract relevant text excerpts as evidence\n\nReturns up to max_excerpts text snippets from plan",
          "line_number": 955,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_find_context_around",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_find_context_around(self, keyword, text, context_chars)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state",
            "NLP libraries",
            "text processing"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Find text excerpt around keyword",
          "line_number": 990,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_confidence",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_confidence(self, execution_results, elements_found, pattern_matches)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate overall confidence score\n\nCombines:\n- Adapter confidence scores\n- Element detection rate\n- Pattern match quality",
          "line_number": 1017,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_explanation",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_generate_explanation(self, question_spec, score, qualitative, elements_found, execution_results, evidence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Generate doctoral-level explanation (150-300 words)\n\nExplains:\n- What was evaluated\n- What was found\n- Why it received this score\n- Implications for policy implementation",
          "line_number": 1053,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_summarize_module_data",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_summarize_module_data(self, result)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Create brief summary of module result data",
          "line_number": 1140,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_meso_cluster",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "generate_meso_cluster(self, cluster_name, cluster_description, micro_answers, cluster_definition)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate MESO-level cluster aggregation\n\nArgs:\n    cluster_name: Cluster identifier (e.g., \"CLUSTER_1\")\n    cluster_description: Human-readable description\n    micro_answers: List of MICRO answers in cluster\n    cluster_definition: Cluster configuration\n    \nReturns:\n    MesoLevelCluster with aggregated analysis",
          "line_number": 1155,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_dimension_scores",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_dimension_scores(self, micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate average scores by dimension (as percentages)",
          "line_number": 1269,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_policy_area_scores",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_policy_area_scores(self, micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate average scores per policy area in percentage scale.",
          "line_number": 1288,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_policy_weighting",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_apply_policy_weighting(self, cluster_id, fallback_score, policy_area_scores, cluster_definition)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Apply rubric-defined weights to policy area contributions.",
          "line_number": 1308,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_coefficient_of_variation",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_coefficient_of_variation(self, scores)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate coefficient of variation for dispersion-aware scoring.",
          "line_number": 1345,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_dispersion",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_classify_dispersion(self, cv, sample_size)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Classify dispersion profile using coefficient of variation.",
          "line_number": 1357,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_dispersion_adjustment",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_apply_dispersion_adjustment(self, base_confidence, cv)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Adjust cluster confidence based on dispersion.",
          "line_number": 1368,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_summarize_probative_tests",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_summarize_probative_tests(self, answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Aggregate probative taxonomy distribution across answers.",
          "line_number": 1377,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_dimension_coverage_index",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_dimension_coverage_index(self, all_micro_answers, plan_metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate coverage ratios per dimension for gating.",
          "line_number": 1397,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_validate_macro_gating",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_validate_macro_gating(self, all_micro_answers, coverage_index)",
          "complexity": "LOW",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Validate macro gating constraints (coverage + causal integrity).",
          "line_number": 1424,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_strengths",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_identify_strengths(self, micro_answers, dimension_scores)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Identify cluster strengths",
          "line_number": 1467,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_weaknesses",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_identify_weaknesses(self, micro_answers, dimension_scores)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Identify cluster weaknesses",
          "line_number": 1509,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_cluster_recommendations",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_generate_cluster_recommendations(self, cluster_name, micro_answers, strengths, weaknesses)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate strategic recommendations for cluster",
          "line_number": 1553,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_assess_evidence_quality",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_assess_evidence_quality(self, micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Assess overall evidence quality",
          "line_number": 1604,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_score_distribution",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_score_distribution(self, micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate distribution of qualitative scores",
          "line_number": 1621,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "generate_macro_convergence",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "generate_macro_convergence(self, all_micro_answers, all_meso_clusters, plan_metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate MACRO-level convergence analysis\n\nArgs:\n    all_micro_answers: All MICRO answers across all questions\n    all_meso_clusters: All MESO clusters\n    plan_metadata: Plan document metadata\n    \nReturns:\n    MacroLevelConvergence with executive summary",
          "line_number": 1635,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_aggregate_macro_score",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_aggregate_macro_score(self, meso_clusters, fallback_score)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Aggregate macro score using rubric-defined cluster weights.",
          "line_number": 1760,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_dimension_convergence",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_dimension_convergence(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate convergence score by dimension (percentages)",
          "line_number": 1814,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_policy_area_convergence",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_policy_area_convergence(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate convergence score by policy area (percentages)",
          "line_number": 1832,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_perform_gap_analysis",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_perform_gap_analysis(self, all_micro_answers, dim_convergence, policy_convergence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Perform comprehensive gap analysis",
          "line_number": 1850,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_agenda_alignment",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_agenda_alignment(self, all_micro_answers, plan_metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate alignment with Decálogo agenda (0.0-1.0)\n\nBased on:\n- Coverage of all dimensions\n- Quality of evidence\n- Overall confidence",
          "line_number": 1907,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_identify_critical_gaps",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_identify_critical_gaps(self, gap_analysis, dim_convergence)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Identify the most critical gaps requiring attention",
          "line_number": 1945,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_strategic_recommendations",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_generate_strategic_recommendations(self, overall_score, dim_convergence, critical_gaps, meso_clusters)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate executive-level strategic recommendations",
          "line_number": 1977,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_classify_plan",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_classify_plan(self, overall_score)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Classify plan using rubric levels (percentage scale 0-100)\n\nUses >= comparisons from high to low to ensure correct assignment.",
          "line_number": 2038,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_synthesize_evidence",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_synthesize_evidence(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Synthesize evidence across all questions",
          "line_number": 2056,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_generate_implementation_roadmap",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_generate_implementation_roadmap(self, critical_gaps, strategic_recommendations)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Generate prioritized implementation roadmap",
          "line_number": 2078,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_overall_distribution",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_overall_distribution(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate overall score distribution",
          "line_number": 2117,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_confidence_metrics",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_confidence_metrics(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate confidence metrics",
          "line_number": 2127,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_apply_macro_prompts",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_apply_macro_prompts(self, all_micro_answers, all_meso_clusters, convergence_by_dimension, convergence_by_policy_area, missing_clusters, critical_gaps, confidence_metrics, plan_metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [
            "Multiple parameters increase error surface"
          ],
          "docstring": "Apply all 5 macro-level analysis prompts\n\nReturns enriched analysis including:\n- Coverage gap assessment\n- Inter-level contradiction detection\n- Bayesian portfolio composition\n- Optimized implementation roadmap\n- Peer-normalized confidence",
          "line_number": 2141,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_dimension_coverage",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_dimension_coverage(self, all_micro_answers, plan_metadata)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate coverage percentage by dimension\n\nCoverage is calculated as: answered_questions / expected_questions_for_dimension\nIf dimension_expected_counts is not provided in plan_metadata, falls back to\ncalculating based on the questions present in all_micro_answers.",
          "line_number": 2231,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_calculate_policy_area_coverage",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_calculate_policy_area_coverage(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Calculate coverage percentage by policy area",
          "line_number": 2286,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_micro_claims",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_micro_claims(self, all_micro_answers)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Extract micro-level claims from answers",
          "line_number": 2309,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_extract_meso_signals",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_extract_meso_signals(self, all_meso_clusters)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Extract meso-level summary signals",
          "line_number": 2328,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_structure_critical_gaps",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_structure_critical_gaps(self, critical_gaps)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Structure critical gaps with effort and impact estimates",
          "line_number": 2340,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "_get_peer_distributions",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "_get_peer_distributions(self, convergence_by_policy_area)",
          "complexity": "LOW",
          "priority": "LOW",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Get peer distributions for normalization (mock data)",
          "line_number": 2366,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_report",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "export_report(self, micro_answers, meso_clusters, macro_convergence, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Export complete report to JSON\n\nArgs:\n    micro_answers: All MICRO-level answers\n    meso_clusters: All MESO-level clusters\n    macro_convergence: MACRO-level convergence\n    output_path: Path to save JSON report",
          "line_number": 2386,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_micro_answer_schema",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "validate_micro_answer_schema(self, answer_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MICRO answer against JSON schema",
          "line_number": 2425,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_meso_cluster_schema",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "validate_meso_cluster_schema(self, cluster_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MESO cluster against JSON schema",
          "line_number": 2443,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_macro_convergence_schema",
          "class": "ReportAssembler",
          "file": "report_assembly.py",
          "signature": "validate_macro_convergence_schema(self, convergence_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssembler must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MACRO convergence against JSON schema",
          "line_number": 2461,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "__init__",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "__init__(self, dimension_descriptions, cluster_weights, cluster_policy_weights, causal_thresholds)",
          "complexity": "MEDIUM",
          "priority": "CRITICAL",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [],
          "risks": [],
          "docstring": "Initialize producer with optional configuration",
          "line_number": 2495,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "produce_micro_answer",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "produce_micro_answer(self, question_spec, execution_results, plan_text)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Produce MICRO-level answer for a single question\n\nReturns: Serializable dictionary with complete answer",
          "line_number": 2515,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_score",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_score(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract quantitative score from MICRO answer",
          "line_number": 2531,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_qualitative",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_qualitative(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract qualitative classification from MICRO answer",
          "line_number": 2535,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_evidence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_evidence(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract evidence excerpts from MICRO answer",
          "line_number": 2539,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_confidence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_confidence(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract confidence score from MICRO answer",
          "line_number": 2543,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_modules",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_modules(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract list of executed modules from MICRO answer",
          "line_number": 2547,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_execution_time",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_execution_time(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract execution time from MICRO answer",
          "line_number": 2551,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_micro_answer_elements_found",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_micro_answer_elements_found(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract detected elements from MICRO answer",
          "line_number": 2555,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "count_micro_evidence_excerpts",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "count_micro_evidence_excerpts(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Count evidence excerpts in MICRO answer",
          "line_number": 2559,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_micro_answer_excellent",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_micro_answer_excellent(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MICRO answer is classified as EXCELENTE",
          "line_number": 2563,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_micro_answer_passing",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_micro_answer_passing(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MICRO answer meets minimum passing threshold",
          "line_number": 2567,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "produce_meso_cluster",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "produce_meso_cluster(self, cluster_name, cluster_description, micro_answers, cluster_definition)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Produce MESO-level cluster aggregation\n\nReturns: Serializable dictionary with cluster analysis",
          "line_number": 2575,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_score",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_score(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract average score from MESO cluster",
          "line_number": 2597,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_policy_areas",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_policy_areas(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract policy areas from MESO cluster",
          "line_number": 2601,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_dimension_scores",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_dimension_scores(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract dimension scores from MESO cluster",
          "line_number": 2605,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_strengths",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_strengths(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract identified strengths from MESO cluster",
          "line_number": 2609,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_weaknesses",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_weaknesses(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract identified weaknesses from MESO cluster",
          "line_number": 2613,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_recommendations",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_recommendations(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract recommendations from MESO cluster",
          "line_number": 2617,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_coverage",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_coverage(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract question coverage percentage from MESO cluster",
          "line_number": 2621,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_meso_cluster_question_counts",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_meso_cluster_question_counts(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract total and answered question counts from MESO cluster",
          "line_number": 2625,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "count_meso_strengths",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "count_meso_strengths(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Count strengths identified in MESO cluster",
          "line_number": 2629,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "count_meso_weaknesses",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "count_meso_weaknesses(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Count weaknesses identified in MESO cluster",
          "line_number": 2633,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_meso_cluster_excellent",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_meso_cluster_excellent(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MESO cluster score is in EXCELENTE range",
          "line_number": 2637,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_meso_cluster_passing",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_meso_cluster_passing(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MESO cluster meets minimum passing threshold",
          "line_number": 2641,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "produce_macro_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "produce_macro_convergence(self, all_micro_answers, all_meso_clusters, plan_metadata)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Produce MACRO-level convergence analysis\n\nReturns: Serializable dictionary with executive summary",
          "line_number": 2649,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_overall_score",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_overall_score(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract overall score from MACRO convergence",
          "line_number": 2673,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_dimension_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_dimension_convergence(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract dimension convergence scores from MACRO",
          "line_number": 2677,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_policy_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_policy_convergence(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract policy area convergence scores from MACRO",
          "line_number": 2681,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_gap_analysis",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_gap_analysis(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract gap analysis from MACRO convergence",
          "line_number": 2685,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_agenda_alignment",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_agenda_alignment(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract agenda alignment score from MACRO",
          "line_number": 2689,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_critical_gaps",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_critical_gaps(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract critical gaps list from MACRO",
          "line_number": 2693,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_strategic_recommendations",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_strategic_recommendations(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract strategic recommendations from MACRO",
          "line_number": 2697,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_classification",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_classification(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract plan classification from MACRO",
          "line_number": 2701,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_evidence_synthesis",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_evidence_synthesis(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract evidence synthesis from MACRO",
          "line_number": 2705,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_implementation_roadmap",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_implementation_roadmap(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract implementation roadmap from MACRO",
          "line_number": 2709,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_score_distribution",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_score_distribution(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract score distribution from MACRO",
          "line_number": 2713,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_macro_confidence_metrics",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_macro_confidence_metrics(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Extract confidence metrics from MACRO",
          "line_number": 2717,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "count_macro_critical_gaps",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "count_macro_critical_gaps(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Count critical gaps in MACRO convergence",
          "line_number": 2721,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "count_macro_strategic_recommendations",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "count_macro_strategic_recommendations(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Count strategic recommendations in MACRO",
          "line_number": 2725,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_macro_excellent",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_macro_excellent(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MACRO overall score is in EXCELENTE range",
          "line_number": 2729,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "is_macro_passing",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "is_macro_passing(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Check if MACRO meets minimum passing threshold",
          "line_number": 2733,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "convert_score_to_percentage",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "convert_score_to_percentage(self, score)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Convert 0-3 score to 0-100 percentage",
          "line_number": 2741,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "convert_percentage_to_score",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "convert_percentage_to_score(self, percentage)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Convert 0-100 percentage to 0-3 score",
          "line_number": 2745,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "classify_score",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "classify_score(self, score)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify a 0-3 score into qualitative level",
          "line_number": 2749,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "classify_percentage",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "classify_percentage(self, percentage)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Classify a 0-100 percentage into qualitative level",
          "line_number": 2753,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_rubric_threshold",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_rubric_threshold(self, level)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get percentage threshold range for a rubric level",
          "line_number": 2760,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_question_rubric_threshold",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_question_rubric_threshold(self, level)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get 0-3 score threshold range for question-level rubric",
          "line_number": 2764,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_dimension_description",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_dimension_description(self, dimension)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get description for a dimension (D1-D6)",
          "line_number": 2772,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "list_dimensions",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "list_dimensions(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "List all dimensions",
          "line_number": 2776,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "list_rubric_levels",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "list_rubric_levels(self)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "List all rubric levels",
          "line_number": 2780,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_causal_threshold",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_causal_threshold(self, dimension)",
          "complexity": "HIGH",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [
            "High computational complexity"
          ],
          "docstring": "Get causal coherence threshold for a dimension",
          "line_number": 2784,
          "decorators": [],
          "execution_requirements": {
            "computational": "HIGH",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 85.0
        },
        {
          "method_name": "get_cluster_weight",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_cluster_weight(self, cluster_id)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get weight for a cluster in macro aggregation",
          "line_number": 2791,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "get_cluster_policy_weights",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "get_cluster_policy_weights(self, cluster_id)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Get policy area weights for a cluster",
          "line_number": 2795,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "export_complete_report",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "export_complete_report(self, micro_answers, meso_clusters, macro_convergence, output_path)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Export complete report to JSON file",
          "line_number": 2803,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "serialize_micro_answer",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "serialize_micro_answer(self, answer)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Serialize MICRO answer to dictionary",
          "line_number": 2823,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "serialize_meso_cluster",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "serialize_meso_cluster(self, cluster)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Serialize MESO cluster to dictionary",
          "line_number": 2827,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "serialize_macro_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "serialize_macro_convergence(self, convergence)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Serialize MACRO convergence to dictionary",
          "line_number": 2831,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "deserialize_micro_answer",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "deserialize_micro_answer(self, data)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Deserialize dictionary to MICRO answer",
          "line_number": 2835,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "deserialize_meso_cluster",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "deserialize_meso_cluster(self, data)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Deserialize dictionary to MESO cluster",
          "line_number": 2839,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "deserialize_macro_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "deserialize_macro_convergence(self, data)",
          "complexity": "MEDIUM",
          "priority": "MEDIUM",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized",
            "Input data must be validated and properly formatted"
          ],
          "risks": [],
          "docstring": "Deserialize dictionary to MACRO convergence",
          "line_number": 2843,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_micro_answer",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "validate_micro_answer(self, answer_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MICRO answer against JSON schema",
          "line_number": 2851,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_meso_cluster",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "validate_meso_cluster(self, cluster_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MESO cluster against JSON schema",
          "line_number": 2855,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        },
        {
          "method_name": "validate_macro_convergence",
          "class": "ReportAssemblyProducer",
          "file": "report_assembly.py",
          "signature": "validate_macro_convergence(self, convergence_data)",
          "complexity": "MEDIUM",
          "priority": "HIGH",
          "dependencies": [
            "Instance state"
          ],
          "prerequisites": [
            "Instance of ReportAssemblyProducer must be initialized"
          ],
          "risks": [],
          "docstring": "Validate MACRO convergence against JSON schema",
          "line_number": 2859,
          "decorators": [],
          "execution_requirements": {
            "computational": "MEDIUM",
            "memory": "MEDIUM",
            "io_bound": false,
            "stateful": true
          },
          "aptitude_score": 100
        }
      ]
    }
  },
  "methods_catalog": [
    {
      "method_name": "__init__",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "__init__(self, use_gpu, language, confidence_threshold)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 281,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_get_spanish_stopwords",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_get_spanish_stopwords(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 322,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_clean_dataframe",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_clean_dataframe(self, df)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 402,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_is_likely_header",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_is_likely_header(self, row)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 420,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_deduplicate_tables",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_deduplicate_tables(self, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 428,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_tables",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_classify_tables(self, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 495,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "analyze_financial_feasibility",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "analyze_financial_feasibility(self, tables, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 521,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_financial_amounts",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_financial_amounts(self, text, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 538,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_funding_source",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_identify_funding_source(self, context)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 585,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_from_budget_table",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_from_budget_table(self, df)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 602,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_analyze_funding_sources",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_analyze_funding_sources(self, indicators, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 642,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_assess_financial_sustainability",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_assess_financial_sustainability(self, indicators, funding_sources)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 663,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_bayesian_risk_inference",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_bayesian_risk_inference(self, indicators, funding_sources, sustainability)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "numpy",
        "scipy",
        "statistical libraries"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 679,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_interpret_risk",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_interpret_risk(self, risk)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 721,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_indicator_to_dict",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_indicator_to_dict(self, ind)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 733,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "identify_responsible_entities",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "identify_responsible_entities(self, text, tables)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 747,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_entities_ner",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_entities_ner(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 761,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_entities_syntax",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_entities_syntax(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 786,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_entity_type",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_classify_entity_type(self, name)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 813,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_from_responsibility_tables",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_from_responsibility_tables(self, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 826,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_consolidate_entities",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_consolidate_entities(self, entities)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 857,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_entity_specificity",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_entity_specificity(self, entities, full_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 891,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "construct_causal_dag",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "construct_causal_dag(self, text, tables, financial_analysis)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 916,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 75.0
    },
    {
      "method_name": "_identify_causal_nodes",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_identify_causal_nodes(self, text, tables, financial_analysis)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 958,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_find_semantic_mentions",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_find_semantic_mentions(self, text, concept, concept_embedding)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1008,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_find_outcome_mentions",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_find_outcome_mentions(self, text, outcome)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1026,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_find_mediator_mentions",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_find_mediator_mentions(self, text, mediator)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1058,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_budget_for_pillar",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_budget_for_pillar(self, pillar, text, financial_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1089,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_causal_edges",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_identify_causal_edges(self, text, nodes)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 1110,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_match_text_to_node",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_match_text_to_node(self, text, nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1173,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_refine_edge_probabilities",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_refine_edge_probabilities(self, edges, text, nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1196,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_break_cycles",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_break_cycles(self, G)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1219,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "estimate_causal_effects",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "estimate_causal_effects(self, dag, text, financial_analysis)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 1234,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 75.0
    },
    {
      "method_name": "_estimate_effect_bayesian",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_estimate_effect_bayesian(self, treatment, outcome, dag, financial_analysis)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "numpy",
        "scipy",
        "statistical libraries"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "No documentation available",
      "line_number": 1259,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_get_prior_effect",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_get_prior_effect(self, treatment, outcome)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Priors informados basados en meta-análisis de programas PDET\nReferencia: Cinelli et al. (2022) - Sensitivity Analysis for Causal Inference",
      "line_number": 1329,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_confounders",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_identify_confounders(self, treatment, outcome, dag)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Identifica confounders usando d-separation (Pearl, 2009)",
      "line_number": 1349,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_counterfactuals",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "generate_counterfactuals(self, dag, causal_effects, financial_analysis)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Genera escenarios contrafactuales usando el framework de Pearl (2009)\nLevel 3 - Counterfactual: \"What if we had done X instead of Y?\"\n\nImplementación basada en:\n- Pearl & Mackenzie (2018) - The Book of Why\n- Sharma & Kiciman (2020) - DoWhy: An End-to-End Library for Causal Inference",
      "line_number": 1369,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_simulate_intervention",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_simulate_intervention(self, intervention, dag, causal_effects, description)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Simula intervención usando do-calculus (Pearl, 2009)\nImplementa: P(Y | do(X=x)) mediante propagación por el DAG",
      "line_number": 1433,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_scenario_narrative",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_generate_scenario_narrative(self, description, intervention, predicted_outcomes, probabilities)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Genera narrativa interpretable del escenario contrafactual",
      "line_number": 1499,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "sensitivity_analysis",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "sensitivity_analysis(self, causal_effects, dag)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Análisis de sensibilidad para supuestos de identificación causal\nBasado en: Cinelli, Forney & Pearl (2022) - \"A Crash Course in Good and Bad Controls\"",
      "line_number": 1529,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_e_value",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_compute_e_value(self, effect)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "E-value: mínima fuerza de confounding no observado para anular el efecto\nFórmula: E = effect_estimate + sqrt(effect_estimate * (effect_estimate - 1))\n\nReferencia: VanderWeele & Ding (2017) - Ann Intern Med",
      "line_number": 1552,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_robustness_value",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_compute_robustness_value(self, effect, dag)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Robustness Value: percentil de la distribución posterior que cruza cero\nValores altos (>0.95) indican alta robustez",
      "line_number": 1569,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_interpret_sensitivity",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_interpret_sensitivity(self, e_value, robustness)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Interpretación de resultados de sensibilidad",
      "line_number": 1588,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "calculate_quality_score",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "calculate_quality_score(self, text, tables, financial_analysis, responsible_entities, causal_dag, causal_effects)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity",
        "Multiple parameters increase error surface"
      ],
      "docstring": "Puntaje bayesiano integral de calidad del PDM\nIntegra todas las dimensiones de análisis con pesos calibrados",
      "line_number": 1605,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_score_financial_component",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_financial_component(self, financial_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Score componente financiero (0-10)",
      "line_number": 1656,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_indicators",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_indicators(self, tables, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Score calidad de indicadores (0-10)",
      "line_number": 1677,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_responsibility_clarity",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_responsibility_clarity(self, entities)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Score claridad de responsables (0-10)",
      "line_number": 1715,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_temporal_consistency",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_temporal_consistency(self, text, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Score consistencia temporal (0-10)",
      "line_number": 1732,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_pdet_alignment",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_pdet_alignment(self, text, tables, dag)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Score alineación con pilares PDET (0-10)",
      "line_number": 1753,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_causal_coherence",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_score_causal_coherence(self, dag, effects)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Score coherencia causal del plan (0-10)",
      "line_number": 1778,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_estimate_score_confidence",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_estimate_score_confidence(self, scores, weights)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Estima intervalo de confianza para el score usando bootstrap",
      "line_number": 1802,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_causal_network",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "export_causal_network(self, dag, output_path)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Exporta el DAG causal en formato GraphML para Gephi/Cytoscape",
      "line_number": 1824,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "generate_executive_report",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "generate_executive_report(self, analysis_results)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Genera reporte ejecutivo en Markdown",
      "line_number": 1841,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_interpret_overall_quality",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_interpret_overall_quality(self, score)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Interpretación del score global",
      "line_number": 1923,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_recommendations",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_generate_recommendations(self, analysis_results)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Genera recomendaciones específicas basadas en el análisis",
      "line_number": 1944,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "analyze_municipal_plan_sync",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "analyze_municipal_plan_sync(self, pdf_path, output_dir)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Synchronous wrapper for analyze_municipal_plan.",
      "line_number": 2022,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_full_text",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_extract_full_text(self, pdf_path)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Extrae texto completo del PDF usando múltiples métodos",
      "line_number": 2137,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_entity_to_dict",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_entity_to_dict(self, entity)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Convierte ResponsibleEntity a diccionario",
      "line_number": 2168,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_effect_to_dict",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_effect_to_dict(self, effect)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Convierte CausalEffect a diccionario",
      "line_number": 2179,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_scenario_to_dict",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_scenario_to_dict(self, scenario)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Convierte CounterfactualScenario a diccionario",
      "line_number": 2194,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_quality_to_dict",
      "class": "PDETMunicipalPlanAnalyzer",
      "file": "financiero_viabilidad_tablas.py",
      "signature": "_quality_to_dict(self, quality)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDETMunicipalPlanAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Convierte QualityScore a diccionario",
      "line_number": 2203,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "MunicipalOntology",
      "file": "Analyzer_one.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 95,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "__init__",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, ontology)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 154,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "extract_semantic_cube",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "extract_semantic_cube(self, document_segments)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract multidimensional semantic cube from document segments.",
      "line_number": 165,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_empty_semantic_cube",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_empty_semantic_cube(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Return empty semantic cube structure.",
      "line_number": 237,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_vectorize_segments",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_vectorize_segments(self, segments)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Vectorize document segments using TF-IDF.",
      "line_number": 258,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_process_segment",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_process_segment(self, segment, idx, vector)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Process individual segment and extract features.",
      "line_number": 273,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_value_chain_link",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_classify_value_chain_link(self, segment)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify segment by value chain link using keyword matching.",
      "line_number": 310,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_policy_domain",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_classify_policy_domain(self, segment)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify segment by policy domain using keyword matching.",
      "line_number": 333,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_cross_cutting_themes",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_classify_cross_cutting_themes(self, segment)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify segment by cross-cutting themes.",
      "line_number": 348,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_semantic_complexity",
      "class": "SemanticAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_calculate_semantic_complexity(self, semantic_cube)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of SemanticAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate semantic complexity of the cube.",
      "line_number": 363,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, ontology)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 384,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "analyze_performance",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "analyze_performance(self, semantic_cube)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PerformanceAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Analyze performance indicators across value chain links.",
      "line_number": 391,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_throughput_metrics",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_calculate_throughput_metrics(self, segments, link_config)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PerformanceAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate throughput metrics for a value chain link.",
      "line_number": 422,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_bottlenecks",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_detect_bottlenecks(self, segments, link_config)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PerformanceAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Detect bottlenecks in value chain link.",
      "line_number": 460,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_loss_functions",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_calculate_loss_functions(self, metrics, link_config)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PerformanceAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate operational loss functions.",
      "line_number": 494,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_recommendations",
      "class": "PerformanceAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_generate_recommendations(self, performance_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PerformanceAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Generate optimization recommendations.",
      "line_number": 528,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, ontology)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 560,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "diagnose_critical_links",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "diagnose_critical_links(self, semantic_cube, performance_analysis)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TextMiningEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Diagnose critical value chain links.",
      "line_number": 577,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_critical_links",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "_identify_critical_links(self, performance_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TextMiningEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Identify critical links based on performance metrics.",
      "line_number": 613,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_analyze_link_text",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "_analyze_link_text(self, segments)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of TextMiningEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Analyze text content for a link.",
      "line_number": 640,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_assess_risks",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "_assess_risks(self, segments, text_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TextMiningEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Assess risks for a value chain link.",
      "line_number": 677,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_interventions",
      "class": "TextMiningEngine",
      "file": "Analyzer_one.py",
      "signature": "_generate_interventions(self, link_name, risk_assessment, text_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TextMiningEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Generate intervention recommendations.",
      "line_number": 705,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "MunicipalAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 742,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "analyze_document",
      "class": "MunicipalAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "analyze_document(self, document_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of MunicipalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Perform comprehensive analysis of a municipal document.",
      "line_number": 750,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_load_document",
      "class": "MunicipalAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_load_document(self, document_path)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of MunicipalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Load and segment document.",
      "line_number": 792,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_summary",
      "class": "MunicipalAnalyzer",
      "file": "Analyzer_one.py",
      "signature": "_generate_summary(self, semantic_cube, performance_analysis, critical_diagnosis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of MunicipalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Generate executive summary of analysis.",
      "line_number": 814,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "CanonicalQuestionSegmenter",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, questionnaire_path, rubric_path, segmentation_method)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1016,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "segment_plan",
      "class": "CanonicalQuestionSegmenter",
      "file": "Analyzer_one.py",
      "signature": "segment_plan(self, plan_text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CanonicalQuestionSegmenter must be initialized"
      ],
      "risks": [],
      "docstring": "Segment *plan_text* and emit evidence manifests per canonical contract.",
      "line_number": 1036,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_build_manifest",
      "class": "CanonicalQuestionSegmenter",
      "file": "Analyzer_one.py",
      "signature": "_build_manifest(self, contract, segments)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CanonicalQuestionSegmenter must be initialized"
      ],
      "risks": [],
      "docstring": "Build deterministic evidence manifest for *contract* across *segments*.",
      "line_number": 1108,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "load_pdf",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "load_pdf(pdf_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Load text from PDF file.",
      "line_number": 1211,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "load_docx",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "load_docx(docx_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Load text from DOCX file.",
      "line_number": 1229,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "segment_text",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "segment_text(text, method)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Segment text using different methods.",
      "line_number": 1246,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "load_canonical_question_contracts",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "load_canonical_question_contracts(questionnaire_path, rubric_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Load canonical question contracts based on questionnaire and rubric.",
      "line_number": 1289,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "segment_by_canonical_questionnaire",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "segment_by_canonical_questionnaire(plan_text, questionnaire_path, rubric_path, segmentation_method)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Convenience wrapper to segment plan text using canonical contracts.",
      "line_number": 1474,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_default_policy_area_id",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "_default_policy_area_id(legacy_policy_area)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Convert legacy policy-area code (e.g., P1) into canonical PAxx format.",
      "line_number": 1490,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_to_canonical_dimension_id",
      "class": "DocumentProcessor",
      "file": "Analyzer_one.py",
      "signature": "_to_canonical_dimension_id(dimension_code)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Convert legacy dimension code (e.g., D1) into canonical DIMxx format.",
      "line_number": 1501,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_to_json",
      "class": "ResultsExporter",
      "file": "Analyzer_one.py",
      "signature": "export_to_json(results, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Export results to JSON file.",
      "line_number": 1516,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_to_excel",
      "class": "ResultsExporter",
      "file": "Analyzer_one.py",
      "signature": "export_to_excel(results, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Export results to Excel file.",
      "line_number": 1526,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_summary_report",
      "class": "ResultsExporter",
      "file": "Analyzer_one.py",
      "signature": "export_summary_report(results, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Export a summary report in text format.",
      "line_number": 1591,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "ConfigurationManager",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, config_path)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1706,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "load_config",
      "class": "ConfigurationManager",
      "file": "Analyzer_one.py",
      "signature": "load_config(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigurationManager must be initialized"
      ],
      "risks": [],
      "docstring": "Load configuration from file or create default.",
      "line_number": 1710,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "save_config",
      "class": "ConfigurationManager",
      "file": "Analyzer_one.py",
      "signature": "save_config(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigurationManager must be initialized"
      ],
      "risks": [],
      "docstring": "Save current configuration to file.",
      "line_number": 1745,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BatchProcessor",
      "file": "Analyzer_one.py",
      "signature": "__init__(self, analyzer)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1757,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "process_directory",
      "class": "BatchProcessor",
      "file": "Analyzer_one.py",
      "signature": "process_directory(self, directory_path, pattern)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BatchProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Process all files matching pattern in directory.",
      "line_number": 1760,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_batch_results",
      "class": "BatchProcessor",
      "file": "Analyzer_one.py",
      "signature": "export_batch_results(self, batch_results, output_dir)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BatchProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Export batch processing results.",
      "line_number": 1783,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_create_batch_summary",
      "class": "BatchProcessor",
      "file": "Analyzer_one.py",
      "signature": "_create_batch_summary(self, batch_results, output_path)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BatchProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Create summary of batch processing results.",
      "line_number": 1805,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianConfidenceCalculator",
      "file": "contradiction_deteccion.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 107,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "calculate_posterior",
      "class": "BayesianConfidenceCalculator",
      "file": "contradiction_deteccion.py",
      "signature": "calculate_posterior(self, evidence_strength, observations, domain_weight)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianConfidenceCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula probabilidad posterior usando inferencia Bayesiana\n\nArgs:\n    evidence_strength: Fuerza de la evidencia [0, 1]\n    observations: Número de observaciones que soportan la evidencia\n    domain_weight: Peso específico del dominio de política",
      "line_number": 112,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 145,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "verify_temporal_consistency",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "verify_temporal_consistency(self, statements)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Verifica consistencia temporal entre declaraciones\n\nReturns:\n    (is_consistent, conflicts_found)",
      "line_number": 153,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_build_timeline",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_build_timeline(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Construye línea temporal a partir de declaraciones",
      "line_number": 182,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_parse_temporal_marker",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_parse_temporal_marker(self, marker)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Parsea marcador temporal a timestamp numérico",
      "line_number": 196,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_has_temporal_conflict",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_has_temporal_conflict(self, event_a, event_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta conflictos temporales entre eventos",
      "line_number": 213,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_are_mutually_exclusive",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_are_mutually_exclusive(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Determina si dos declaraciones son mutuamente excluyentes",
      "line_number": 224,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_resources",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_extract_resources(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extrae recursos mencionados en el texto",
      "line_number": 236,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_check_deadline_constraints",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_check_deadline_constraints(self, timeline)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Verifica violaciones de restricciones de plazo",
      "line_number": 251,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_should_precede",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_should_precede(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Determina si stmt_a debe preceder a stmt_b",
      "line_number": 268,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_temporal_type",
      "class": "TemporalLogicVerifier",
      "file": "contradiction_deteccion.py",
      "signature": "_classify_temporal_type(self, marker)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "Clasifica el tipo de marcador temporal",
      "line_number": 273,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "__init__(self, model_name, spacy_model, device)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 287,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_initialize_pdm_patterns",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_initialize_pdm_patterns(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Inicializa patrones específicos de PDMs colombianos",
      "line_number": 323,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "detect",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "detect(self, text, plan_name, dimension)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Detecta contradicciones con análisis multi-dimensional avanzado\n\nArgs:\n    text: Texto del plan de desarrollo\n    plan_name: Nombre del PDM\n    dimension: Dimensión del plan siendo analizada\n\nReturns:\n    Análisis completo con contradicciones detectadas y métricas",
      "line_number": 348,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_policy_statements",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_extract_policy_statements(self, text, dimension)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extrae declaraciones de política estructuradas del texto",
      "line_number": 418,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_embeddings",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_generate_embeddings(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Genera embeddings semánticos para las declaraciones",
      "line_number": 459,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_build_knowledge_graph",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_build_knowledge_graph(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Construye grafo de conocimiento para razonamiento",
      "line_number": 486,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_semantic_contradictions",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_detect_semantic_contradictions(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta contradicciones semánticas usando transformers",
      "line_number": 512,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_numerical_inconsistencies",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_detect_numerical_inconsistencies(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta inconsistencias numéricas con análisis estadístico",
      "line_number": 556,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_temporal_conflicts",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_detect_temporal_conflicts(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta conflictos temporales usando verificación lógica",
      "line_number": 608,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_logical_incompatibilities",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_detect_logical_incompatibilities(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta incompatibilidades lógicas usando razonamiento en grafo",
      "line_number": 652,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_resource_conflicts",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_detect_resource_conflicts(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Detecta conflictos en asignación de recursos",
      "line_number": 705,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_coherence_metrics",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_coherence_metrics(self, contradictions, statements, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Calcula métricas avanzadas de coherencia del documento",
      "line_number": 760,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_global_semantic_coherence",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_global_semantic_coherence(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula coherencia semántica global usando embeddings",
      "line_number": 817,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_objective_alignment",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_objective_alignment(self, statements)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula alineación entre objetivos declarados",
      "line_number": 845,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_graph_fragmentation",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_graph_fragmentation(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula fragmentación del grafo de conocimiento",
      "line_number": 871,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_contradiction_entropy",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_contradiction_entropy(self, contradictions)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula entropía de distribución de tipos de contradicción",
      "line_number": 885,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_syntactic_complexity",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_syntactic_complexity(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Calcula complejidad sintáctica del documento",
      "line_number": 911,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_dependency_depth",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_get_dependency_depth(self, token)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula profundidad de un token en el árbol de dependencias",
      "line_number": 940,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_confidence_interval",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_confidence_interval(self, score, n_observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula intervalo de confianza del 95% para el score",
      "line_number": 949,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_resolution_recommendations",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_generate_resolution_recommendations(self, contradictions)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Genera recomendaciones específicas para resolver contradicciones",
      "line_number": 972,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_affected_sections",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_identify_affected_sections(self, conflicts)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Identifica secciones del plan afectadas por contradicciones",
      "line_number": 1046,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_serialize_contradiction",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_serialize_contradiction(self, contradiction)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Serializa evidencia de contradicción para output",
      "line_number": 1062,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_graph_statistics",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_get_graph_statistics(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Obtiene estadísticas del grafo de conocimiento",
      "line_number": 1087,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_temporal_markers",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_extract_temporal_markers(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extrae marcadores temporales del texto",
      "line_number": 1104,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_quantitative_claims",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_extract_quantitative_claims(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extrae afirmaciones cuantitativas estructuradas",
      "line_number": 1125,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_parse_number",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_parse_number(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Parsea número desde texto",
      "line_number": 1155,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_resource_mentions",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_extract_resource_mentions(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extrae menciones de recursos con montos",
      "line_number": 1164,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_determine_semantic_role",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_determine_semantic_role(self, sent)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Determina el rol semántico de una oración",
      "line_number": 1187,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_dependencies",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_identify_dependencies(self, sent, doc)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Identifica dependencias entre declaraciones",
      "line_number": 1206,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_context_window",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_get_context_window(self, text, start, end, window_size)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Obtiene ventana de contexto alrededor de una posición",
      "line_number": 1229,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_similarity",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_similarity(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula similaridad entre dos declaraciones",
      "line_number": 1235,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_contradiction",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_classify_contradiction(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Clasifica probabilidad de contradicción en texto",
      "line_number": 1241,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_domain_weight",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_get_domain_weight(self, dimension)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Obtiene peso específico del dominio",
      "line_number": 1254,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_suggest_resolutions",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_suggest_resolutions(self, contradiction_type)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Sugiere resoluciones específicas por tipo de contradicción",
      "line_number": 1266,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_are_comparable_claims",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_are_comparable_claims(self, claim_a, claim_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Determina si dos afirmaciones cuantitativas son comparables",
      "line_number": 1297,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_text_similarity",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_text_similarity(self, text_a, text_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula similaridad simple entre textos",
      "line_number": 1311,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_numerical_divergence",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_numerical_divergence(self, claim_a, claim_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula divergencia entre valores numéricos",
      "line_number": 1329,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_statistical_significance_test",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_statistical_significance_test(self, claim_a, claim_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Realiza test de significancia estadística",
      "line_number": 1349,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_has_logical_conflict",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_has_logical_conflict(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Determina si hay conflicto lógico entre declaraciones",
      "line_number": 1380,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_are_conflicting_allocations",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_are_conflicting_allocations(self, amount_a, amount_b, total)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Determina si las asignaciones de recursos están en conflicto",
      "line_number": 1409,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_determine_relation_type",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_determine_relation_type(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Determina el tipo de relación entre dos declaraciones",
      "line_number": 1426,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_severity",
      "class": "PolicyContradictionDetector",
      "file": "contradiction_deteccion.py",
      "signature": "_calculate_severity(self, stmt_a, stmt_b)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyContradictionDetector must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula la severidad de una contradicción entre declaraciones",
      "line_number": 1448,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "encode",
      "class": "EmbeddingProtocol",
      "file": "embedding_policy.py",
      "signature": "encode(self, texts, batch_size, normalize)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingProtocol must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 108,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "__init__",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 154,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "chunk_document",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "chunk_document(self, text, document_metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Chunk document with advanced semantic awareness.\n\nReturns chunks with preserved structure and P-D-Q context.",
      "line_number": 158,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_normalize_text",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_normalize_text(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Normalize text while preserving structure.",
      "line_number": 226,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_recursive_split",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_recursive_split(self, text, target_size, overlap)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Recursive character splitting with semantic boundary respect.\n\nPriority: Paragraph > Sentence > Word > Character",
      "line_number": 233,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_find_sentence_boundary",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_find_sentence_boundary(self, text, start, end)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Find sentence boundary using Spanish punctuation rules.",
      "line_number": 275,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_sections",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_extract_sections(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract document sections with hierarchical structure.",
      "line_number": 286,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_tables",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_extract_tables(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Identify table regions in document.",
      "line_number": 302,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_lists",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_extract_lists(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Identify list structures.",
      "line_number": 316,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_infer_pdq_context",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_infer_pdq_context(self, chunk_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized"
      ],
      "risks": [],
      "docstring": "Infer P-D-Q context from chunk content.\n\nUses heuristics based on Colombian policy vocabulary.",
      "line_number": 323,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_contains_table",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_contains_table(self, chunk_text, tables)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized"
      ],
      "risks": [],
      "docstring": "Check if chunk contains table markers.",
      "line_number": 384,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_contains_list",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_contains_list(self, chunk_text, lists)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized"
      ],
      "risks": [],
      "docstring": "Check if chunk contains list structures.",
      "line_number": 393,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_find_section",
      "class": "AdvancedSemanticChunker",
      "file": "embedding_policy.py",
      "signature": "_find_section(self, chunk_text, sections)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedSemanticChunker must be initialized"
      ],
      "risks": [],
      "docstring": "Find section title for chunk.",
      "line_number": 397,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "__init__(self, prior_strength)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize Bayesian analyzer.\n\nArgs:\n    prior_strength: Prior belief strength (1.0 = weak, 10.0 = strong)",
      "line_number": 425,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "evaluate_policy_metric",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "evaluate_policy_metric(self, observed_values, n_posterior_samples)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Bayesian evaluation of policy metric with uncertainty quantification.\n\nReturns posterior distribution, credible intervals, and evidence strength.",
      "line_number": 436,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_beta_binomial_posterior",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "_beta_binomial_posterior(self, observations, n_samples)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Beta-Binomial conjugate posterior for proportion metrics.\n\nPrior: Beta(α, β)\nLikelihood: Binomial\nPosterior: Beta(α + successes, β + failures)",
      "line_number": 485,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_normal_normal_posterior",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "_normal_normal_posterior(self, observations, n_samples)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Normal-Normal conjugate posterior for continuous metrics.\n\nPrior: Normal(μ₀, σ₀²)\nLikelihood: Normal(μ, σ²)\nPosterior: Normal(μ_post, σ_post²)",
      "line_number": 512,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_evidence_strength",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "_classify_evidence_strength(self, credible_interval_width)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify evidence strength based on posterior uncertainty.",
      "line_number": 545,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_coherence",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "_compute_coherence(self, observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Compute numerical coherence (consistency) score.\n\nUses coefficient of variation and statistical tests.",
      "line_number": 558,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_null_evaluation",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "_null_evaluation(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Return null evaluation when no data available.",
      "line_number": 581,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "compare_policies",
      "class": "BayesianNumericalAnalyzer",
      "file": "embedding_policy.py",
      "signature": "compare_policies(self, policy_a_values, policy_b_values)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianNumericalAnalyzer must be initialized"
      ],
      "risks": [],
      "docstring": "Bayesian comparison of two policy metrics.\n\nReturns probability that A > B and Bayes factor.",
      "line_number": 591,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PolicyCrossEncoderReranker",
      "file": "embedding_policy.py",
      "signature": "__init__(self, model_name, max_length, retry_handler)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize cross-encoder reranker.\n\nArgs:\n    model_name: HuggingFace model name (multilingual preferred)\n    max_length: Maximum sequence length for cross-encoder\n    retry_handler: Optional RetryHandler for model loading",
      "line_number": 655,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "rerank",
      "class": "PolicyCrossEncoderReranker",
      "file": "embedding_policy.py",
      "signature": "rerank(self, query, candidates, top_k, min_score)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyCrossEncoderReranker must be initialized"
      ],
      "risks": [],
      "docstring": "Rerank candidates using cross-encoder attention.\n\nReturns top-k chunks with relevance scores.",
      "line_number": 694,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "__init__(self, config, retry_handler)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 777,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "process_document",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "process_document(self, document_text, document_metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Process complete PDM document into semantic chunks with embeddings.\n\nArgs:\n    document_text: Full document text\n    document_metadata: Metadata including doc_id, municipality, year\n\nReturns:\n    List of semantic chunks with embeddings and P-D-Q context",
      "line_number": 826,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "semantic_search",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "semantic_search(self, query, document_chunks, pdq_filter, use_reranking)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Advanced semantic search with P-D-Q filtering and reranking.\n\nPipeline:\n1. Bi-encoder retrieval (fast, approximate)\n2. P-D-Q filtering (if specified)\n3. Cross-encoder reranking (precise)\n4. MMR diversification\n\nArgs:\n    query: Search query\n    document_chunks: Pool of chunks to search\n    pdq_filter: Optional P-D-Q context filter\n    use_reranking: Enable cross-encoder reranking\n\nReturns:\n    Ranked list of (chunk, score) tuples",
      "line_number": 874,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "evaluate_policy_numerical_consistency",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "evaluate_policy_numerical_consistency(self, chunks, pdq_context)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Bayesian evaluation of numerical consistency for policy metric.\n\nExtracts numerical values from chunks matching P-D-Q context,\nperforms rigorous statistical analysis with uncertainty quantification.\n\nArgs:\n    chunks: Document chunks to analyze\n    pdq_context: P-D-Q context to filter relevant chunks\n\nReturns:\n    Bayesian evaluation with credible intervals and evidence strength",
      "line_number": 944,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "compare_policy_interventions",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "compare_policy_interventions(self, intervention_a_chunks, intervention_b_chunks, pdq_context)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Bayesian comparison of two policy interventions.\n\nReturns probability and evidence for superiority.",
      "line_number": 996,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_pdq_report",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "generate_pdq_report(self, document_chunks, target_pdq)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Generate comprehensive analytical report for P-D-Q question.\n\nCombines semantic search, numerical analysis, and evidence synthesis.",
      "line_number": 1016,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_embed_texts",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_embed_texts(self, texts)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Generate embeddings with caching and retry logic.",
      "line_number": 1070,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_filter_by_pdq",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_filter_by_pdq(self, chunks, pdq_filter)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Filter chunks by P-D-Q context.",
      "line_number": 1127,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_mmr",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_apply_mmr(self, ranked_results)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Apply Maximal Marginal Relevance for diversification.\n\nBalances relevance with diversity to avoid redundant results.",
      "line_number": 1139,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_numerical_values",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_extract_numerical_values(self, chunks)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Extract numerical values from chunks using advanced patterns.\n\nFocuses on policy-relevant metrics: percentages, amounts, counts.",
      "line_number": 1193,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_query_from_pdq",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_generate_query_from_pdq(self, pdq)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Generate search query from P-D-Q identifier.",
      "line_number": 1248,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_overall_confidence",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_compute_overall_confidence(self, relevant_chunks, numerical_eval)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Compute overall confidence score combining semantic and numerical evidence.\n\nConsiders:\n- Number of relevant chunks\n- Semantic relevance scores\n- Numerical evidence strength\n- Statistical coherence",
      "line_number": 1256,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_cached_similarity",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "_cached_similarity(self, text_hash1, text_hash2)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Cached similarity computation for performance.\nAssumes embeddings are cached in self._embedding_cache using text_hash as key.",
      "line_number": 1297,
      "decorators": [
        "<ast.Call object at 0x7f1eea036850>"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_diagnostics",
      "class": "PolicyAnalysisEmbedder",
      "file": "embedding_policy.py",
      "signature": "get_diagnostics(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisEmbedder must be initialized"
      ],
      "risks": [],
      "docstring": "Get system diagnostics and performance metrics.",
      "line_number": 1305,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "__init__(self, config, model_tier, retry_handler)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize producer with optional configuration",
      "line_number": 1398,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "process_document",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "process_document(self, document_text, document_metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Process document into semantic chunks with embeddings",
      "line_number": 1417,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_chunk_count",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_chunk_count(self, chunks)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get number of chunks",
      "line_number": 1425,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_chunk_text",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_chunk_text(self, chunk)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract text from chunk",
      "line_number": 1429,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_chunk_embedding",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_chunk_embedding(self, chunk)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract embedding from chunk",
      "line_number": 1433,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_chunk_metadata",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_chunk_metadata(self, chunk)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract metadata from chunk",
      "line_number": 1437,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_chunk_pdq_context",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_chunk_pdq_context(self, chunk)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract P-D-Q context from chunk",
      "line_number": 1441,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "semantic_search",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "semantic_search(self, query, document_chunks, pdq_filter, use_reranking)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Advanced semantic search with reranking",
      "line_number": 1449,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_search_result_chunk",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_search_result_chunk(self, result)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract chunk from search result",
      "line_number": 1461,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_search_result_score",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_search_result_score(self, result)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract relevance score from search result",
      "line_number": 1467,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_pdq_report",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "generate_pdq_report(self, document_chunks, target_pdq)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Generate comprehensive analytical report for P-D-Q question",
      "line_number": 1477,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_pdq_evidence_count",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_pdq_evidence_count(self, report)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract evidence count from P-D-Q report",
      "line_number": 1485,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_pdq_numerical_evaluation",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_pdq_numerical_evaluation(self, report)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract numerical evaluation from P-D-Q report",
      "line_number": 1489,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_pdq_evidence_passages",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_pdq_evidence_passages(self, report)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract evidence passages from P-D-Q report",
      "line_number": 1493,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_pdq_confidence",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_pdq_confidence(self, report)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract confidence from P-D-Q report",
      "line_number": 1497,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "evaluate_numerical_consistency",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "evaluate_numerical_consistency(self, chunks, pdq_context)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Evaluate numerical consistency with Bayesian analysis",
      "line_number": 1505,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_point_estimate",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_point_estimate(self, evaluation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract point estimate from Bayesian evaluation",
      "line_number": 1515,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_credible_interval",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_credible_interval(self, evaluation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract 95% credible interval from Bayesian evaluation",
      "line_number": 1519,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_evidence_strength",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_evidence_strength(self, evaluation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract evidence strength classification",
      "line_number": 1525,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_numerical_coherence",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_numerical_coherence(self, evaluation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract numerical coherence score",
      "line_number": 1531,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "compare_policy_interventions",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "compare_policy_interventions(self, intervention_a_chunks, intervention_b_chunks, pdq_context)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Bayesian comparison of two policy interventions",
      "line_number": 1539,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_comparison_probability",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_comparison_probability(self, comparison)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract probability that A is better than B",
      "line_number": 1550,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_comparison_bayes_factor",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_comparison_bayes_factor(self, comparison)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract Bayes factor from comparison",
      "line_number": 1554,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_comparison_difference_mean",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_comparison_difference_mean(self, comparison)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract mean difference from comparison",
      "line_number": 1558,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_diagnostics",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_diagnostics(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get system diagnostics and performance metrics",
      "line_number": 1566,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_config",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_config(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get current configuration",
      "line_number": 1570,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "list_policy_domains",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "list_policy_domains(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "List all policy domains",
      "line_number": 1574,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "list_analytical_dimensions",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "list_analytical_dimensions(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "List all analytical dimensions",
      "line_number": 1578,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_policy_domain_description",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_policy_domain_description(self, domain)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get description for policy domain",
      "line_number": 1582,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_analytical_dimension_description",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "get_analytical_dimension_description(self, dimension)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get description for analytical dimension",
      "line_number": 1586,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "create_pdq_identifier",
      "class": "EmbeddingPolicyProducer",
      "file": "embedding_policy.py",
      "signature": "create_pdq_identifier(self, policy, dimension, question)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EmbeddingPolicyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Create P-D-Q identifier",
      "line_number": 1590,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__post_init__",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "__post_init__(self)",
      "complexity": "MEDIUM",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedGraphNode must be initialized"
      ],
      "risks": [],
      "docstring": "Inicializa metadatos por defecto si no son provistos.",
      "line_number": 159,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_normalize_metadata",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "_normalize_metadata(self, metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedGraphNode must be initialized"
      ],
      "risks": [],
      "docstring": "Normaliza metadatos garantizando primitivos JSON y valores por defecto.",
      "line_number": 181,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_sanitize_confidence",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "_sanitize_confidence(value)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 204,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_sanitize_created",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "_sanitize_created(value)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 212,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_sanitize_metadata_value",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "_sanitize_metadata_value(value)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 223,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "to_serializable_dict",
      "class": "AdvancedGraphNode",
      "file": "teoria_cambio.py",
      "signature": "to_serializable_dict(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedGraphNode must be initialized"
      ],
      "risks": [],
      "docstring": "Convierte el nodo en un diccionario serializable compatible con JSON Schema.",
      "line_number": 233,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Inicializa el motor con un sistema de cache optimizado.",
      "line_number": 296,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_es_conexion_valida",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "_es_conexion_valida(origen, destino)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Verifica la validez de una conexión causal según la jerarquía estructural.",
      "line_number": 303,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "construir_grafo_causal",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "construir_grafo_causal(self)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TeoriaCambio must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Construye y cachea el grafo causal canónico.",
      "line_number": 308,
      "decorators": [
        "<ast.Call object at 0x7f1ee9ea9090>"
      ],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "validacion_completa",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "validacion_completa(self, grafo)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TeoriaCambio must be initialized"
      ],
      "risks": [],
      "docstring": "Ejecuta una validación estructural exhaustiva de la teoría de cambio.",
      "line_number": 331,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extraer_categorias",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "_extraer_categorias(grafo)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Extrae el conjunto de categorías presentes en el grafo.",
      "line_number": 347,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_validar_orden_causal",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "_validar_orden_causal(grafo)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Identifica las aristas que violan el orden causal axiomático.",
      "line_number": 356,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_encontrar_caminos_completos",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "_encontrar_caminos_completos(grafo)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Encuentra todos los caminos simples desde nodos INSUMOS a CAUSALIDAD.",
      "line_number": 367,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generar_sugerencias_internas",
      "class": "TeoriaCambio",
      "file": "teoria_cambio.py",
      "signature": "_generar_sugerencias_internas(validacion)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Genera un listado de sugerencias accionables basadas en los resultados.",
      "line_number": 391,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "__init__(self, graph_type)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 460,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "add_node",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "add_node(self, name, dependencies, role, metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Agrega un nodo enriquecido al grafo.",
      "line_number": 472,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "add_edge",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "add_edge(self, from_node, to_node, weight)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Agrega una arista dirigida con peso opcional.",
      "line_number": 484,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_initialize_rng",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_initialize_rng(self, plan_name, salt)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Inicializa el generador de números aleatorios con una semilla determinista.\n\nAudit Point 1.1: Deterministic Seeding (RNG)\nInitializes numpy/random RNG with deterministic seed for reproducibility.\nSets reproducible=True in MonteCarloAdvancedResult.\n\nArgs:\n    plan_name: Plan identifier for seed derivation\n    salt: Optional salt for sensitivity analysis\n\nReturns:\n    Generated seed value for audit logging",
      "line_number": 493,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_is_acyclic",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_is_acyclic(nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Detección de ciclos mediante el algoritmo de Kahn (ordenación topológica).",
      "line_number": 520,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_subgraph",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_generate_subgraph(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Genera un subgrafo aleatorio del grafo principal.",
      "line_number": 543,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "calculate_acyclicity_pvalue",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "calculate_acyclicity_pvalue(self, plan_name, iterations)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Cálculo avanzado de p-value con un marco estadístico completo.",
      "line_number": 563,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "last_serialized_nodes",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "last_serialized_nodes(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Obtiene la instantánea más reciente de nodos serializados.",
      "line_number": 614,
      "decorators": [
        "property"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_nodes",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "export_nodes(self, validate, schema_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Serializa los nodos del grafo y opcionalmente valida contra JSON Schema.",
      "line_number": 622,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_node_validator",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_get_node_validator(cls, schema_path)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Obtiene (y cachea) el validador JSON Schema para nodos avanzados.",
      "line_number": 655,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_perform_sensitivity_analysis_internal",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_perform_sensitivity_analysis_internal(self, plan_name, base_p_value, iterations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Análisis de sensibilidad interno optimizado para evitar cálculos redundantes.",
      "line_number": 687,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_confidence_interval",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_calculate_confidence_interval(s, n, conf)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Calcula el intervalo de confianza de Wilson.",
      "line_number": 730,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_statistical_power",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_calculate_statistical_power(s, n, alpha)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Calcula el poder estadístico a posteriori.",
      "line_number": 744,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_bayesian_posterior",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_calculate_bayesian_posterior(likelihood, prior)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "numpy",
        "scipy",
        "statistical libraries"
      ],
      "prerequisites": [],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Calcula la probabilidad posterior Bayesiana simple.",
      "line_number": 755,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_calculate_node_importance",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_calculate_node_importance(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula una métrica de importancia para cada nodo.",
      "line_number": 763,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_graph_stats",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "get_graph_stats(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Obtiene estadísticas estructurales del grafo.",
      "line_number": 784,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_create_empty_result",
      "class": "AdvancedDAGValidator",
      "file": "teoria_cambio.py",
      "signature": "_create_empty_result(self, plan_name, seed, timestamp)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedDAGValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Crea un resultado vacío para grafos sin nodos.",
      "line_number": 794,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 830,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "execute_suite",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "execute_suite(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Ejecuta la suite completa de validación industrial.",
      "line_number": 840,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_engine_readiness",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "validate_engine_readiness(self)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Valida la disponibilidad y tiempo de instanciación de los motores de análisis.",
      "line_number": 872,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_causal_categories",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "validate_causal_categories(self)",
      "complexity": "HIGH",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Valida la completitud y el orden axiomático de las categorías causales.",
      "line_number": 891,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "validate_connection_matrix",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "validate_connection_matrix(self)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Valida la matriz de transiciones causales.",
      "line_number": 908,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "run_performance_benchmarks",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "run_performance_benchmarks(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Ejecuta benchmarks de rendimiento para las operaciones críticas del motor.",
      "line_number": 928,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_benchmark_operation",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "_benchmark_operation(self, operation_name, callable_obj, threshold)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Mide el tiempo de ejecución de una operación y registra la métrica.",
      "line_number": 957,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_log_metric",
      "class": "IndustrialGradeValidator",
      "file": "teoria_cambio.py",
      "signature": "_log_metric(self, name, value, unit, threshold)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialGradeValidator must be initialized"
      ],
      "risks": [],
      "docstring": "Registra y reporta una métrica de validación.",
      "line_number": 967,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "classify_test",
      "class": "BeachEvidentialTest",
      "file": "dereck_beach.py",
      "signature": "classify_test(necessity, sufficiency)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Classify evidential test type based on necessity and sufficiency.\n\nBeach calibration:\n- Necessity > 0.7 → High necessity\n- Sufficiency > 0.7 → High sufficiency",
      "line_number": 122,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "apply_test_logic",
      "class": "BeachEvidentialTest",
      "file": "dereck_beach.py",
      "signature": "apply_test_logic(test_type, evidence_found, prior, bayes_factor)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Apply Beach test-specific logic to Bayesian updating.\n\nCRITICAL RULES:\n1. Hoop Test FAIL → posterior ≈ 0 (knock-out)\n2. Smoking Gun PASS → multiply prior by large BF (>10)\n3. Doubly Decisive → extreme updates (BF > 100 or < 0.01)\n\nReturns: (posterior_confidence, interpretation)",
      "line_number": 143,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "CDAFException",
      "file": "dereck_beach.py",
      "signature": "__init__(self, message, details, stage, recoverable)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 197,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_format_message",
      "class": "CDAFException",
      "file": "dereck_beach.py",
      "signature": "_format_message(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFException must be initialized"
      ],
      "risks": [],
      "docstring": "Format error message with structured information",
      "line_number": 205,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "to_dict",
      "class": "CDAFException",
      "file": "dereck_beach.py",
      "signature": "to_dict(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFException must be initialized"
      ],
      "risks": [],
      "docstring": "Convert exception to structured dictionary",
      "line_number": 215,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "check_sum_to_one",
      "class": "MechanismTypeConfig",
      "file": "dereck_beach.py",
      "signature": "check_sum_to_one(cls, v, values)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Validate that probabilities sum to approximately 1.0",
      "line_number": 289,
      "decorators": [
        "<ast.Call object at 0x7f1ee9d69690>"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config_path)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 447,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_load_config",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "_load_config(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Load YAML configuration file",
      "line_number": 458,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_load_default_config",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "_load_default_config(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Load default configuration if custom fails",
      "line_number": 475,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_validate_config",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "_validate_config(self)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Validate configuration structure using Pydantic schema",
      "line_number": 562,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "get(self, key, default)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Get configuration value with dot notation support",
      "line_number": 593,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_bayesian_threshold",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "get_bayesian_threshold(self, key)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "numpy",
        "scipy",
        "statistical libraries"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Get Bayesian threshold with type safety",
      "line_number": 604,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "get_mechanism_prior",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "get_mechanism_prior(self, mechanism_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Get mechanism type prior probability with type safety",
      "line_number": 610,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_performance_setting",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "get_performance_setting(self, key)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Get performance setting with type safety",
      "line_number": 616,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "update_priors_from_feedback",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "update_priors_from_feedback(self, feedback_data)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Self-reflective loop: Update priors based on audit feedback\nImplements frontier paradigm of learning from results\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Applies penalties to mechanism types with implementation_failure flags\n- Heavily penalizes \"miracle\" mechanisms failing necessity/sufficiency tests\n- Ensures mean mech_uncertainty decreases by ≥5% over iterations",
      "line_number": 622,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_save_prior_history",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "_save_prior_history(self, feedback_data, uncertainty_reduction)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Save prior history for learning across documents\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Tracks uncertainty reduction over iterations\n- Records penalty applications and test failures",
      "line_number": 718,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_load_uncertainty_history",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "_load_uncertainty_history(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Load historical uncertainty measurements\n\nHARMONIC FRONT 4: Required for tracking ≥5% reduction over 10 iterations",
      "line_number": 781,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "check_uncertainty_reduction_criterion",
      "class": "ConfigLoader",
      "file": "dereck_beach.py",
      "signature": "check_uncertainty_reduction_criterion(self, current_uncertainty)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ConfigLoader must be initialized"
      ],
      "risks": [],
      "docstring": "Check if mean mechanism_type uncertainty has decreased ≥5% over 10 iterations\n\nHARMONIC FRONT 4 QUALITY CRITERIA:\nSuccess verified if mean mech_uncertainty decreases by ≥5% over 10 sequential PDM analyses",
      "line_number": 806,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PDFProcessor",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config, retry_handler)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 852,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "load_document",
      "class": "PDFProcessor",
      "file": "dereck_beach.py",
      "signature": "load_document(self, pdf_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDFProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Load PDF document with retry logic",
      "line_number": 861,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "extract_text",
      "class": "PDFProcessor",
      "file": "dereck_beach.py",
      "signature": "extract_text(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PDFProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Extract all text from PDF",
      "line_number": 894,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "extract_tables",
      "class": "PDFProcessor",
      "file": "dereck_beach.py",
      "signature": "extract_tables(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDFProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Extract tables from PDF",
      "line_number": 912,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "extract_sections",
      "class": "PDFProcessor",
      "file": "dereck_beach.py",
      "signature": "extract_sections(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PDFProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Extract document sections based on patterns",
      "line_number": 943,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config, nlp_model)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 966,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "extract_causal_hierarchy",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "extract_causal_hierarchy(self, text)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Extract complete causal hierarchy from text",
      "line_number": 974,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "_extract_goals",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_extract_goals(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract all goals from text",
      "line_number": 993,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_parse_goal_context",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_parse_goal_context(self, goal_id, context)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Parse goal context to extract structured information",
      "line_number": 1015,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_add_node_to_graph",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_add_node_to_graph(self, node)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Add node to causal graph",
      "line_number": 1051,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_causal_links",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_extract_causal_links(self, text)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "AGUJA I: El Prior Informado Adaptativo\nExtract causal links using Bayesian inference with adaptive priors",
      "line_number": 1059,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_calculate_semantic_distance",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_calculate_semantic_distance(self, source, target)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate semantic distance between nodes using spaCy embeddings\n\nPERFORMANCE NOTE: This method can be optimized with:\n1. Vectorized operations using numpy for batch processing\n2. Embedding caching to avoid recomputing spaCy vectors\n3. Async processing for large documents with many nodes\n4. Alternative: BERT/transformer embeddings for higher fidelity (SOTA)\n\nCurrent implementation prioritizes determinism over speed.\nEnable performance.cache_embeddings in config for production use.",
      "line_number": 1194,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_type_transition_prior",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_calculate_type_transition_prior(self, source, target)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate prior based on historical transition frequencies between goal types",
      "line_number": 1232,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_check_structural_violation",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_check_structural_violation(self, source, target)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "AUDIT POINT 2.1: Structural Veto (D6-Q2)\n\nCheck if causal link violates structural hierarchy based on TeoriaCambio axioms.\nImplements set-theoretic constraints per Goertz & Mahoney 2012.\n\nReturns:\n    None if link is valid, otherwise a string describing the violation",
      "line_number": 1255,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_language_specificity",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_calculate_language_specificity(self, keyword, policy_area, context)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Assess specificity of causal language (epistemic certainty)\n\nHarmonic Front 3 - Enhancement 4: Language Specificity Assessment\nEnhanced to check policy-specific vocabulary (patrones_verificacion) for current\nPolicy Area (P1–P10), not just generic causal keywords.\n\nFor D6-Q5 (Contextual/Differential Focus): rewards use of specialized terminology\nthat anchors intervention in social/cultural context (e.g., \"catastro multipropósito\",\n\"reparación integral\", \"mujeres rurales\", \"guardia indígena\").",
      "line_number": 1295,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_assess_temporal_coherence",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_assess_temporal_coherence(self, source, target)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Assess temporal coherence based on verb sequences",
      "line_number": 1405,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_assess_financial_consistency",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_assess_financial_consistency(self, source, target)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Assess financial alignment between connected nodes",
      "line_number": 1436,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_textual_proximity",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_calculate_textual_proximity(self, source, target, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Calculate how often node IDs appear together in text windows",
      "line_number": 1460,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_initialize_prior",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_initialize_prior(self, source, target)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Initialize prior distribution for causal link",
      "line_number": 1482,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_composite_likelihood",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_calculate_composite_likelihood(self, evidence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate composite likelihood from multiple evidence components\n\nEnhanced with:\n- Nonlinear transformation rewarding triangulation\n- Evidence diversity verification across analytical domains",
      "line_number": 1500,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_build_type_hierarchy",
      "class": "CausalExtractor",
      "file": "dereck_beach.py",
      "signature": "_build_type_hierarchy(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Build hierarchy based on goal types",
      "line_number": 1559,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "MechanismPartExtractor",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config, nlp_model)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1584,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "extract_entity_activity",
      "class": "MechanismPartExtractor",
      "file": "dereck_beach.py",
      "signature": "extract_entity_activity(self, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of MechanismPartExtractor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract Entity-Activity tuple from text",
      "line_number": 1590,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_normalize_entity",
      "class": "MechanismPartExtractor",
      "file": "dereck_beach.py",
      "signature": "_normalize_entity(self, entity)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of MechanismPartExtractor must be initialized"
      ],
      "risks": [],
      "docstring": "Normalize entity name using aliases",
      "line_number": 1628,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1637,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "trace_financial_allocation",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "trace_financial_allocation(self, tables, nodes, graph)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of FinancialAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Trace financial allocations to programs/goals\n\nHarmonic Front 3 - Enhancement 5: Single-Case Counterfactual Budget Check\nIncorporates logic from single-case counterfactuals to test minimal sufficiency.\nFor D3-Q3 (Traceability/Resources): checks if resource X (BPIN code) were removed,\nwould the mechanism (Product) still execute? Only boosts budget traceability score\nif allocation is tied to a specific project.",
      "line_number": 1646,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_process_financial_table",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "_process_financial_table(self, table, nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of FinancialAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Process a single financial table",
      "line_number": 1676,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_parse_amount",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "_parse_amount(self, value)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of FinancialAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Parse monetary amount from various formats",
      "line_number": 1747,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_match_program_to_node",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "_match_program_to_node(self, program_id, nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of FinancialAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Match program ID to existing node using fuzzy matching\n\nEnhanced for D1-Q3 / D3-Q3 Financial Traceability:\n- Implements confidence penalty if fuzzy match ratio < 100\n- Reduces node.financial_allocation confidence by 15% for imperfect matches\n- Tracks match quality for overall financial traceability scoring",
      "line_number": 1762,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_perform_counterfactual_budget_check",
      "class": "FinancialAuditor",
      "file": "dereck_beach.py",
      "signature": "_perform_counterfactual_budget_check(self, nodes, graph)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of FinancialAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Harmonic Front 3 - Enhancement 5: Counterfactual Sufficiency Test for D3-Q3\n\nTests minimal sufficiency: if resource X (BPIN code) were removed, would the\nmechanism (Product) still execute? Only boosts budget traceability score if\nallocation is tied to a specific project.\n\nFor D3-Q3 (Traceability/Resources): ensures funding is necessary for the mechanism\nand prevents false positives from generic or disconnected budget entries.",
      "line_number": 1817,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1912,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "audit_evidence_traceability",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "audit_evidence_traceability(self, nodes)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Audit evidence traceability for all nodes\n\nEnhanced with D3-Q1 Ficha Técnica validation:\n- Cross-checks baseline/target against extracted quantitative_claims\n- Verifies DNP INDICATOR_STRUCTURE compliance for producto nodes\n- Scores 'Excelente' only if ≥80% of productos pass full audit",
      "line_number": 1919,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "audit_sequence_logic",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "audit_sequence_logic(self, graph)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Audit logical sequence of activities",
      "line_number": 2049,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "bayesian_counterfactual_audit",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "bayesian_counterfactual_audit(self, nodes, graph, historical_data, pdet_alignment)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "numpy",
        "scipy",
        "statistical libraries"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "AGUJA III: El Auditor Contrafactual Bayesiano\nPerform counterfactual audit using Bayesian causal reasoning\n\nHarmonic Front 3: Enhanced to consume pdet_alignment scores for D4-Q5 and D5-Q4 integration",
      "line_number": 2089,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "_build_normative_dag",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_build_normative_dag(self)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "networkx",
        "graph structures"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Build normative DAG of expected relationships in well-formed plans",
      "line_number": 2137,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_get_default_historical_priors",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_get_default_historical_priors(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Get default historical priors if no data is available",
      "line_number": 2160,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_audit_direct_evidence",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_audit_direct_evidence(self, nodes, scm_dag, historical_data)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Layer 1: Audit direct evidence of required components\n\nEnhanced with highly specific Bayesian priors for rare evidence items.\nExample: D2-Q4 risk matrix, D5-Q5 unwanted effects are rare in poor PDMs.",
      "line_number": 2176,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_audit_causal_implications",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_audit_causal_implications(self, nodes, graph, direct_evidence)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Layer 2: Audit causal implications of omissions",
      "line_number": 2278,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_audit_systemic_risk",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_audit_systemic_risk(self, nodes, graph, direct_evidence, causal_implications, pdet_alignment)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "AUDIT POINT 2.3: Policy Alignment Dual Constraint\nLayer 3: Calculate systemic risk from accumulated omissions\n\nHarmonic Front 3 - Enhancement 1: Alignment and Systemic Risk Linkage\nIncorporates Policy Alignment scores (PND, ODS, RRI) as variable in systemic risk.\n\nFor D5-Q4 (Riesgos Sistémicos) and D4-Q5 (Alineación):\n- If pdet_alignment ≤ 0.60, applies 1.2× multiplier to risk_score\n- Excelente on D5-Q4 requires risk_score < 0.10\n\nImplements dual constraints integrating macro-micro causality per Lieberman 2015.",
      "line_number": 2331,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_optimal_remediations",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_generate_optimal_remediations(self, direct_evidence, causal_implications, systemic_risk)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Generate prioritized remediation recommendations",
      "line_number": 2449,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_remediation_text",
      "class": "OperationalizationAuditor",
      "file": "dereck_beach.py",
      "signature": "_get_remediation_text(self, omission, node_id)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of OperationalizationAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Get specific remediation text for an omission",
      "line_number": 2497,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config, nlp_model)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 2528,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_log_refactored_components",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_log_refactored_components(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Log status of refactored Bayesian components (F1.2)",
      "line_number": 2569,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "infer_mechanisms",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "infer_mechanisms(self, nodes, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Infer latent causal mechanisms using hierarchical Bayesian modeling\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Tracks mean mechanism_type uncertainty for quality criteria\n- Reports uncertainty reduction metrics",
      "line_number": 2580,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_infer_single_mechanism",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_infer_single_mechanism(self, node, text, all_nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Infer mechanism for a single product node",
      "line_number": 2619,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_observations",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_extract_observations(self, node, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract textual observations related to the mechanism",
      "line_number": 2661,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_infer_mechanism_type",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_infer_mechanism_type(self, observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Infer mechanism type using Bayesian updating",
      "line_number": 2703,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_infer_activity_sequence",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_infer_activity_sequence(self, observations, mechanism_type_posterior)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Infer activity sequence parameters",
      "line_number": 2741,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_coherence_factor",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_calculate_coherence_factor(self, node, observations, all_nodes)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate mechanism coherence score",
      "line_number": 2769,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_test_sufficiency",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_test_sufficiency(self, node, observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Test if mechanism is sufficient to produce the outcome",
      "line_number": 2810,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_test_necessity",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_test_necessity(self, node, observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "AUDIT POINT 2.2: Mechanism Necessity Hoop Test\n\nTest if mechanism is necessary by checking documented components:\n- Entity (responsable)\n- Activity (verb lemma sequence)\n- Budget (presupuesto asignado)\n\nImplements Beach 2017 Hoop Tests for necessity verification.\nPer Falleti & Lynch 2009, Bayesian-deterministic hybrid boosts mechanism depth.\n\nReturns:\n    Dict with 'is_necessary', 'missing_components', and remediation text",
      "line_number": 2838,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_necessity_remediation",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_generate_necessity_remediation(self, node_id, missing_components)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Generate remediation text for failed necessity test",
      "line_number": 2922,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_quantify_uncertainty",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_quantify_uncertainty(self, mechanism_type_posterior, sequence_posterior, coherence_score)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Quantify epistemic uncertainty",
      "line_number": 2941,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_detect_gaps",
      "class": "BayesianMechanismInference",
      "file": "dereck_beach.py",
      "signature": "_detect_gaps(self, node, observations, uncertainty)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianMechanismInference must be initialized"
      ],
      "risks": [],
      "docstring": "Detect documentation gaps based on uncertainty",
      "line_number": 2975,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "CausalInferenceSetup",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 3022,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "classify_goal_dynamics",
      "class": "CausalInferenceSetup",
      "file": "dereck_beach.py",
      "signature": "classify_goal_dynamics(self, nodes)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalInferenceSetup must be initialized"
      ],
      "risks": [],
      "docstring": "Classify dynamics for each goal",
      "line_number": 3029,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "assign_probative_value",
      "class": "CausalInferenceSetup",
      "file": "dereck_beach.py",
      "signature": "assign_probative_value(self, nodes)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalInferenceSetup must be initialized"
      ],
      "risks": [],
      "docstring": "Assign probative test types to nodes",
      "line_number": 3040,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "identify_failure_points",
      "class": "CausalInferenceSetup",
      "file": "dereck_beach.py",
      "signature": "identify_failure_points(self, graph, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CausalInferenceSetup must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Identify single points of failure in causal chain\n\nHarmonic Front 3 - Enhancement 2: Contextual Failure Point Detection\nExpands risk_pattern to explicitly include localized contextual factors from rubrics:\n- restricciones territoriales\n- patrones culturales machistas\n- limitación normativa\n\nFor D6-Q5 (Enfoque Diferencial/Restricciones): Excelente requires ≥3 distinct\ncontextual factors correctly mapped to nodes, satisfying enfoque_diferencial\nand analisis_contextual criteria.",
      "line_number": 3099,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config, output_dir)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 3201,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "generate_causal_diagram",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "generate_causal_diagram(self, graph, policy_code)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportingEngine must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Generate causal diagram visualization",
      "line_number": 3207,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "generate_accountability_matrix",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "generate_accountability_matrix(self, graph, policy_code)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportingEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Generate accountability matrix in Markdown",
      "line_number": 3294,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_confidence_report",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "generate_confidence_report(self, nodes, graph, causal_chains, audit_results, financial_auditor, sequence_warnings, policy_code)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportingEngine must be initialized"
      ],
      "risks": [
        "High computational complexity",
        "Multiple parameters increase error surface"
      ],
      "docstring": "Generate extraction confidence report",
      "line_number": 3353,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "_calculate_quality_score",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "_calculate_quality_score(self, traceability, financial, logic, ea)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportingEngine must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate overall quality score (0-100)",
      "line_number": 3443,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_causal_model_json",
      "class": "ReportingEngine",
      "file": "dereck_beach.py",
      "signature": "generate_causal_model_json(self, graph, nodes, policy_code)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportingEngine must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Generate structured JSON export of causal model",
      "line_number": 3453,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "__init__",
      "class": "CDAFFramework",
      "file": "dereck_beach.py",
      "signature": "__init__(self, config_path, output_dir, log_level)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 3505,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "process_document",
      "class": "CDAFFramework",
      "file": "dereck_beach.py",
      "signature": "process_document(self, pdf_path, policy_code)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFFramework must be initialized"
      ],
      "risks": [],
      "docstring": "Main processing pipeline",
      "line_number": 3576,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_feedback_from_audit",
      "class": "CDAFFramework",
      "file": "dereck_beach.py",
      "signature": "_extract_feedback_from_audit(self, inferred_mechanisms, counterfactual_audit, audit_results)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFFramework must be initialized"
      ],
      "risks": [],
      "docstring": "Extract feedback data from audit results for self-reflective prior updating\n\nThis implements the frontier paradigm of learning from audit results\nto improve future inference accuracy.\n\nHARMONIC FRONT 4 ENHANCEMENT:\n- Reduces mechanism_type_priors for mechanisms with implementation_failure flags\n- Tracks necessity/sufficiency test failures\n- Penalizes \"miracle\" mechanisms that fail counterfactual tests",
      "line_number": 3687,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_validate_dnp_compliance",
      "class": "CDAFFramework",
      "file": "dereck_beach.py",
      "signature": "_validate_dnp_compliance(self, nodes, graph, policy_code)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFFramework must be initialized"
      ],
      "risks": [],
      "docstring": "Validate DNP compliance for all nodes/projects\nGenerates DNP compliance report",
      "line_number": 3785,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_dnp_report",
      "class": "CDAFFramework",
      "file": "dereck_beach.py",
      "signature": "_generate_dnp_report(self, dnp_results, policy_code)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of CDAFFramework must be initialized"
      ],
      "risks": [],
      "docstring": "Generate comprehensive DNP compliance report",
      "line_number": 3861,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_bayes_factor",
      "class": "BayesFactorTable",
      "file": "dereck_beach.py",
      "signature": "get_bayes_factor(cls, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Obtiene BF medio para tipo de test",
      "line_number": 3984,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_version",
      "class": "BayesFactorTable",
      "file": "dereck_beach.py",
      "signature": "get_version(cls)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Version de tabla BF para trazabilidad",
      "line_number": 3992,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "__init__(self, calibration_params)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 4018,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "calculate_likelihood_adaptativo",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "calculate_likelihood_adaptativo(self, evidence_dict, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT I-1: Calcula likelihood adaptativo con BF y dominios\n\nArgs:\n    evidence_dict: Evidencia por caso {semantic, temporal, financial, structural}\n    test_type: Tipo de test evidencial (straw, hoop, smoking, doubly)\n\nReturns:\n    Dict con p_mechanism, BF_used, domain_weights, triangulation_bonus, etc.",
      "line_number": 4036,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_adjust_domain_weights",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "_adjust_domain_weights(self, domain_scores)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "Ajusta pesos si falta dominio: baja a 0 y reparte",
      "line_number": 4103,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "sensitivity_analysis",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "sensitivity_analysis(self, evidence_dict, test_type, perturbation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT I-2: Sensibilidad, OOD y ablation evidencial\n\nPerturba cada componente ±10% y reporta ∂p/∂component top-3.\nEjecuta ablaciones: sólo textual, sólo financiero, sólo estructural.\n\nCRITERIA:\n- |delta_p_sensitivity|_max ≤ 0.15\n- sign_concordance ≥ 2/3\n- OOD_drop ≤ 0.10",
      "line_number": 4130,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_perturb_evidence",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "_perturb_evidence(self, evidence_dict, domain, perturbation)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "Perturba un dominio específico",
      "line_number": 4217,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_add_ood_noise",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "_add_ood_noise(self, evidence_dict)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "Genera set OOD con ruido semántico y tablas malformadas",
      "line_number": 4231,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_traceability_record",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "generate_traceability_record(self, evidence_dict, test_type, result, seed)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT I-3: Trazabilidad y reproducibilidad\n\nCon semilla fija, guarda bf_table_version, weights_version,\nsnippets textuales con offsets, campos financieros usados.\n\nMETRICS:\n- Re-ejecución con misma semilla produce hash_result idéntico\n- trace_completeness ≥ 0.95",
      "line_number": 4244,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_quality_criteria",
      "class": "AdaptivePriorCalculator",
      "file": "dereck_beach.py",
      "signature": "validate_quality_criteria(self, validation_samples)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdaptivePriorCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "Valida criterios de calidad en conjunto de validación sintética\n\nQUALITY CRITERIA:\n- BrierScore ≤ 0.20\n- ACE ∈ [−0.02, 0.02]\n- Cobertura CI95% ∈ [92%, 98%]\n- Monotonicidad verificada",
      "line_number": 4308,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "__init__(self, mechanism_priors)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 4431,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "infer_mechanism_posterior",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "infer_mechanism_posterior(self, observations, n_iter, burn_in, n_chains)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT II-1: Inferencia jerárquica con MCMC\n\nEstima posterior(mechanism_type, activity_sequence | obs) usando MCMC.\n\nArgs:\n    observations: Dict con {verbos, co_ocurrencias, coherence, structural_signals}\n    n_iter: Iteraciones MCMC (≥500)\n    burn_in: Burn-in iterations (≥100)\n    n_chains: Número de cadenas para R-hat (≥2)\n\nReturns:\n    Dict con type_posterior, sequence_mode, coherence_score, entropy, CI95, R-hat, ESS",
      "line_number": 4451,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_run_mcmc_chain",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_run_mcmc_chain(self, observations, n_iter, burn_in, seed)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Ejecuta una cadena MCMC con Metropolis-Hastings",
      "line_number": 4562,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_likelihood",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_calculate_likelihood(self, mechanism_type, observations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula likelihood de observations dado mechanism_type",
      "line_number": 4615,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_mode_sequence",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_get_mode_sequence(self, samples)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Obtiene secuencia modal (tipo más frecuente)",
      "line_number": 4643,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_r_hat",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_calculate_r_hat(self, chains)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula Gelman-Rubin R-hat para diagnóstico de convergencia",
      "line_number": 4654,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_ess",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_calculate_ess(self, samples)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula Effective Sample Size (simplificado)",
      "line_number": 4688,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "posterior_predictive_check",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "posterior_predictive_check(self, posterior_samples, observed_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT II-2: Posterior Predictive Checks + Ablation\n\nGenera datos simulados desde posterior y compara con observados.\nRealiza ablation de pasos de secuencia.\n\nArgs:\n    posterior_samples: Samples del posterior MCMC\n    observed_data: Datos observados reales\n\nReturns:\n    Dict con ppd_p_value, distance_metric, ablation_curve, criteria_met",
      "line_number": 4713,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_ablation_analysis",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_ablation_analysis(self, posterior_samples, observed_data)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Mide caída en coherence al quitar pasos de secuencia",
      "line_number": 4786,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "verify_conditional_independence",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "verify_conditional_independence(self, dag, independence_tests)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT II-3: Independencias y parsimonia\n\nVerifica d-separaciones implicadas por el DAG.\nCalcula ΔWAIC entre modelo jerárquico vs. nulo.\n\nArgs:\n    dag: NetworkX DiGraph del modelo causal\n    independence_tests: Lista de tuplas (X, Y, Z) para test X ⊥ Y | Z\n\nReturns:\n    Dict con independence_tests, delta_waic, model_preference, criteria_met",
      "line_number": 4805,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_independence_tests",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_generate_independence_tests(self, dag, n_tests)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Genera tests de independencia automáticamente desde DAG",
      "line_number": 4886,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_waic_difference",
      "class": "HierarchicalGenerativeModel",
      "file": "dereck_beach.py",
      "signature": "_calculate_waic_difference(self, dag)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of HierarchicalGenerativeModel must be initialized"
      ],
      "risks": [],
      "docstring": "Calcula ΔWAIC = WAIC_hierarchical - WAIC_null (simplificado)\n\nEn producción: usar arviz.waic() con trace real de PyMC/Stan",
      "line_number": 4912,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 4958,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "construct_scm",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "construct_scm(self, dag, structural_equations)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT III-1: Construcción de SCM\n\nConstruye SCM = {DAG, f_i} desde grafo y ecuaciones estructurales.\n\nArgs:\n    dag: NetworkX DiGraph (debe ser acíclico)\n    structural_equations: Dict {node: function} para f_i\n\nReturns:\n    SCM con DAG validado y funciones estructurales\n\nRaises:\n    ValueError: Si DAG no es acíclico",
      "line_number": 4962,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_create_default_equations",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "_create_default_equations(self, dag)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Crea ecuaciones estructurales lineales por defecto",
      "line_number": 5006,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "counterfactual_query",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "counterfactual_query(self, intervention, target, evidence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT III-1: Queries gemelas (omission, sufficiency, necessity)\n\nEvalúa:\n- Factual: P(Y | evidence)\n- Counterfactual: P(Y | do(X=x), evidence)\n- Causal effect, sufficiency, necessity\n\nArgs:\n    intervention: {nodo: valor} para do(.) operation\n    target: Nodo objetivo Y\n    evidence: Evidencia observada (opcional)\n\nReturns:\n    Dict con p_factual, p_counterfactual, causal_effect, is_sufficient, is_necessary",
      "line_number": 5028,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_evaluate_factual",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "_evaluate_factual(self, target, evidence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Evalúa P(target | evidence) propagando hacia adelante en DAG",
      "line_number": 5101,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_evaluate_counterfactual",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "_evaluate_counterfactual(self, target, intervention, evidence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Evalúa P(target | do(intervention), evidence) con DAG mutilado",
      "line_number": 5143,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_test_effect_stability",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "_test_effect_stability(self, intervention, target, evidence, n_perturbations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "Testa estabilidad al variar priors/ecuaciones ±10%",
      "line_number": 5180,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "aggregate_risk_and_prioritize",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "aggregate_risk_and_prioritize(self, omission_score, insufficiency_score, unnecessity_score, causal_effect, feasibility, cost)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [
        "High computational complexity",
        "Multiple parameters increase error surface"
      ],
      "docstring": "PROMPT III-2: Riesgo sistémico y priorización con incertidumbre\n\nFórmulas:\n- risk = 0.50·omission + 0.35·insufficiency + 0.15·unnecessity\n- priority = |effect|·feasibility/(cost+ε)·(1−uncertainty)\n\nArgs:\n    omission_score: Riesgo de omisión de mecanismo [0,1]\n    insufficiency_score: Insuficiencia del mecanismo [0,1]\n    unnecessity_score: Mecanismo innecesario [0,1]\n    causal_effect: Efecto causal estimado\n    feasibility: Factibilidad de intervención [0,1]\n    cost: Costo relativo (>0)\n\nReturns:\n    Dict con risk_score, success_probability, priority, recommendations",
      "line_number": 5217,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "refutation_and_sanity_checks",
      "class": "BayesianCounterfactualAuditor",
      "file": "dereck_beach.py",
      "signature": "refutation_and_sanity_checks(self, dag, target, treatment, confounders)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianCounterfactualAuditor must be initialized"
      ],
      "risks": [],
      "docstring": "PROMPT III-3: Refutación, negativos y cordura do(.)\n\nEjecuta:\n1. Controles negativos: nodos irrelevantes → |efecto| ≤ 0.05\n2. Pruebas placebo: permuta edges no causales\n3. Sanity checks: añadir cofactores no reduce P(Y|do(X=1))\n\nArgs:\n    dag: Grafo causal\n    target: Nodo objetivo Y\n    treatment: Nodo de tratamiento X\n    confounders: Lista de cofactores\n\nReturns:\n    Dict con negative_controls, placebo_effect, sanity_violations, recommendation",
      "line_number": 5328,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize producer",
      "line_number": 5558,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "classify_test_type",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "classify_test_type(self, necessity, sufficiency)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify evidential test type based on necessity and sufficiency",
      "line_number": 5567,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "apply_test_logic",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "apply_test_logic(self, test_type, evidence_found, prior, bayes_factor)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Apply Beach test-specific logic to Bayesian updating",
      "line_number": 5571,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_hoop_test",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_hoop_test(self, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if test is hoop test",
      "line_number": 5583,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_smoking_gun",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_smoking_gun(self, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if test is smoking gun",
      "line_number": 5587,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_doubly_decisive",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_doubly_decisive(self, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if test is doubly decisive",
      "line_number": 5591,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_straw_in_wind",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_straw_in_wind(self, test_type)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if test is straw in wind",
      "line_number": 5595,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "create_hierarchical_model",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "create_hierarchical_model(self, mechanism_priors)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Create hierarchical generative model",
      "line_number": 5603,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "infer_mechanism_posterior",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "infer_mechanism_posterior(self, model, observations, n_iter, burn_in, n_chains)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Infer mechanism posterior using MCMC",
      "line_number": 5610,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 95.0
    },
    {
      "method_name": "get_type_posterior",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_type_posterior(self, inference)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract type posterior from inference",
      "line_number": 5623,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_sequence_mode",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_sequence_mode(self, inference)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract sequence mode from inference",
      "line_number": 5627,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_coherence_score",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_coherence_score(self, inference)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract coherence score from inference",
      "line_number": 5631,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_r_hat",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_r_hat(self, inference)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract R-hat convergence diagnostic",
      "line_number": 5635,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_ess",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_ess(self, inference)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract effective sample size",
      "line_number": 5639,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_inference_uncertain",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_inference_uncertain(self, inference)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Check if inference has high uncertainty",
      "line_number": 5643,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "posterior_predictive_check",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "posterior_predictive_check(self, model, posterior_samples, observed_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Run posterior predictive checks",
      "line_number": 5651,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_ppd_p_value",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_ppd_p_value(self, ppc)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract posterior predictive p-value",
      "line_number": 5660,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_ablation_curve",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_ablation_curve(self, ppc)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract ablation curve from PPC",
      "line_number": 5664,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_ppc_recommendation",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_ppc_recommendation(self, ppc)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract recommendation from PPC",
      "line_number": 5668,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "verify_conditional_independence",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "verify_conditional_independence(self, model, dag, independence_tests)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Verify conditional independencies in DAG",
      "line_number": 5676,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_independence_tests",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_independence_tests(self, verification)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract independence tests from verification",
      "line_number": 5685,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_delta_waic",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_delta_waic(self, verification)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract delta WAIC from verification",
      "line_number": 5689,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_model_preference",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_model_preference(self, verification)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract model preference from verification",
      "line_number": 5693,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "create_auditor",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "create_auditor(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Create Bayesian counterfactual auditor",
      "line_number": 5701,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "construct_scm",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "construct_scm(self, auditor, dag, structural_equations)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Construct structural causal model",
      "line_number": 5705,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "counterfactual_query",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "counterfactual_query(self, auditor, intervention, target, evidence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Execute counterfactual query",
      "line_number": 5714,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_causal_effect",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_causal_effect(self, query)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Extract causal effect from query",
      "line_number": 5724,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "is_sufficient",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_sufficient(self, query)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if mechanism is sufficient",
      "line_number": 5728,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_necessary",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_necessary(self, query)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if mechanism is necessary",
      "line_number": 5732,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_effect_stable",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "is_effect_stable(self, query)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if effect is stable",
      "line_number": 5736,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "aggregate_risk",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "aggregate_risk(self, auditor, omission_score, insufficiency_score, unnecessity_score, causal_effect, feasibility, cost)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [
        "High computational complexity",
        "Multiple parameters increase error surface"
      ],
      "docstring": "Aggregate risk and calculate priority",
      "line_number": 5744,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 80.0
    },
    {
      "method_name": "get_risk_score",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_risk_score(self, aggregation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract risk score from aggregation",
      "line_number": 5764,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_success_probability",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_success_probability(self, aggregation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract success probability from aggregation",
      "line_number": 5768,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_priority",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_priority(self, aggregation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract priority from aggregation",
      "line_number": 5772,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_recommendations",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_recommendations(self, aggregation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract recommendations from aggregation",
      "line_number": 5776,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "refutation_checks",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "refutation_checks(self, auditor, dag, target, treatment, confounders)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Execute refutation and sanity checks",
      "line_number": 5784,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 95.0
    },
    {
      "method_name": "get_negative_controls",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_negative_controls(self, refutation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract negative controls from refutation",
      "line_number": 5797,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_placebo_effect",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_placebo_effect(self, refutation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract placebo effect from refutation",
      "line_number": 5801,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_sanity_violations",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_sanity_violations(self, refutation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract sanity violations from refutation",
      "line_number": 5805,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "all_checks_passed",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "all_checks_passed(self, refutation)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if all refutation checks passed",
      "line_number": 5809,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_refutation_recommendation",
      "class": "DerekBeachProducer",
      "file": "dereck_beach.py",
      "signature": "get_refutation_recommendation(self, refutation)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of DerekBeachProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract recommendation from refutation",
      "line_number": 5813,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "from_legacy",
      "class": "ProcessorConfig",
      "file": "policy_processor.py",
      "signature": "from_legacy(cls)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Construct configuration from legacy parameter names.",
      "line_number": 350,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate",
      "class": "ProcessorConfig",
      "file": "policy_processor.py",
      "signature": "validate(self)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ProcessorConfig must be initialized"
      ],
      "risks": [],
      "docstring": "Validate configuration parameters.",
      "line_number": 358,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianEvidenceScorer",
      "file": "policy_processor.py",
      "signature": "__init__(self, prior_confidence, entropy_weight)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 394,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "compute_evidence_score",
      "class": "BayesianEvidenceScorer",
      "file": "policy_processor.py",
      "signature": "compute_evidence_score(self, matches, total_corpus_size, pattern_specificity)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianEvidenceScorer must be initialized"
      ],
      "risks": [],
      "docstring": "Compute probabilistic confidence score for evidence matches.\n\nArgs:\n    matches: List of matched text segments\n    total_corpus_size: Total document size in characters\n    pattern_specificity: Pattern discrimination power [0,1]\n\nReturns:\n    Calibrated confidence score in [0, 1]",
      "line_number": 399,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_shannon_entropy",
      "class": "BayesianEvidenceScorer",
      "file": "policy_processor.py",
      "signature": "_calculate_shannon_entropy(values)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Calculate normalized Shannon entropy for value distribution.",
      "line_number": 440,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PolicyTextProcessor",
      "file": "policy_processor.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 466,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "normalize_unicode",
      "class": "PolicyTextProcessor",
      "file": "policy_processor.py",
      "signature": "normalize_unicode(self, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyTextProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Apply canonical Unicode normalization (NFC/NFKC).",
      "line_number": 473,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "segment_into_sentences",
      "class": "PolicyTextProcessor",
      "file": "policy_processor.py",
      "signature": "segment_into_sentences(self, text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyTextProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Segment text into sentences with context-aware boundary detection.\nHandles abbreviations, numerical lists, and Colombian naming conventions.",
      "line_number": 477,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "extract_contextual_window",
      "class": "PolicyTextProcessor",
      "file": "policy_processor.py",
      "signature": "extract_contextual_window(self, text, match_position, window_size)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PolicyTextProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract semantically coherent context window around a match.",
      "line_number": 503,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "compile_pattern",
      "class": "PolicyTextProcessor",
      "file": "policy_processor.py",
      "signature": "compile_pattern(self, pattern_str)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyTextProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Cache and compile regex patterns for performance.",
      "line_number": 519,
      "decorators": [
        "<ast.Call object at 0x7f1ee9eaaf10>"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "to_dict",
      "class": "EvidenceBundle",
      "file": "policy_processor.py",
      "signature": "to_dict(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of EvidenceBundle must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 539,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "__init__",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "__init__(self, config, questionnaire_path)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 559,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_load_questionnaire",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_load_questionnaire(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Load and validate DECALOGO questionnaire structure.",
      "line_number": 603,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compile_pattern_registry",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_compile_pattern_registry(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Compile all causal patterns into efficient regex objects.",
      "line_number": 617,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_build_point_patterns",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_build_point_patterns(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Extract and compile patterns for each policy point from questionnaire.",
      "line_number": 628,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "process",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "process(self, raw_text)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Execute comprehensive policy plan analysis.\n\nArgs:\n    raw_text: Sanitized policy document text\n\nReturns:\n    Structured analysis results with evidence bundles and confidence scores",
      "line_number": 657,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_match_patterns_in_sentences",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_match_patterns_in_sentences(self, compiled_patterns, relevant_sentences)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Execute pattern matching across relevant sentences and collect matches with positions.\n\nArgs:\n    compiled_patterns: List of compiled regex patterns to match\n    relevant_sentences: Filtered sentences to search within\n    \nReturns:\n    Tuple of (matched_strings, match_positions)",
      "line_number": 749,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_evidence_confidence",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_compute_evidence_confidence(self, matches, text_length, pattern_specificity)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate confidence score for evidence based on pattern matches and contextual factors.\n\nArgs:\n    matches: List of matched pattern strings\n    text_length: Total length of the document text\n    pattern_specificity: Specificity coefficient for pattern weighting\n    \nReturns:\n    Computed confidence score",
      "line_number": 773,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_construct_evidence_bundle",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_construct_evidence_bundle(self, dimension, category, matches, positions, confidence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Assemble evidence bundle from matched patterns and computed confidence.\n\nArgs:\n    dimension: Causal dimension classification\n    category: Specific category within dimension\n    matches: List of matched pattern strings\n    positions: List of match positions in text\n    confidence: Computed confidence score\n    \nReturns:\n    Serialized evidence bundle dictionary",
      "line_number": 792,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_run_contradiction_analysis",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_run_contradiction_analysis(self, text, metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Execute contradiction and temporal diagnostics across all dimensions.",
      "line_number": 822,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_quality_score",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_calculate_quality_score(self, dimension_analysis, contradiction_bundle, performance_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Aggregate key indicators into a structured QualityScore dataclass.",
      "line_number": 930,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_point_evidence",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_extract_point_evidence(self, text, sentences, point_code)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract evidence for a specific policy point across all dimensions.",
      "line_number": 998,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_analyze_causal_dimensions",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_analyze_causal_dimensions(self, text, sentences)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Perform global analysis of causal dimensions across entire document.",
      "line_number": 1037,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_metadata",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_extract_metadata(text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Extract key metadata from policy document header.",
      "line_number": 1077,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_compute_avg_confidence",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_compute_avg_confidence(dimension_analysis)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [],
      "prerequisites": [],
      "risks": [],
      "docstring": "Calculate average confidence across all dimensions.",
      "line_number": 1108,
      "decorators": [
        "staticmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_empty_result",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "_empty_result(self)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Return structure for failed/empty processing.",
      "line_number": 1117,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_results",
      "class": "IndustrialPolicyProcessor",
      "file": "policy_processor.py",
      "signature": "export_results(self, results, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of IndustrialPolicyProcessor must be initialized"
      ],
      "risks": [],
      "docstring": "Export analysis results to JSON with formatted output.",
      "line_number": 1133,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "AdvancedTextSanitizer",
      "file": "policy_processor.py",
      "signature": "__init__(self, config)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1156,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "sanitize",
      "class": "AdvancedTextSanitizer",
      "file": "policy_processor.py",
      "signature": "sanitize(self, raw_text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedTextSanitizer must be initialized"
      ],
      "risks": [],
      "docstring": "Execute comprehensive text sanitization pipeline.\n\nPipeline stages:\n1. Unicode normalization (NFC)\n2. Structure element protection\n3. Whitespace normalization\n4. Special character handling\n5. Encoding validation",
      "line_number": 1165,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_protect_structure",
      "class": "AdvancedTextSanitizer",
      "file": "policy_processor.py",
      "signature": "_protect_structure(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedTextSanitizer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Mark structural elements for protection during sanitization.",
      "line_number": 1202,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_restore_structure",
      "class": "AdvancedTextSanitizer",
      "file": "policy_processor.py",
      "signature": "_restore_structure(self, text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of AdvancedTextSanitizer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Remove protection markers after sanitization.",
      "line_number": 1233,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "read_text",
      "class": "ResilientFileHandler",
      "file": "policy_processor.py",
      "signature": "read_text(cls, file_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Read text file with automatic encoding detection and fallback cascade.\n\nArgs:\n    file_path: Path to input file\n\nReturns:\n    Decoded text content\n\nRaises:\n    IOError: If file cannot be read with any supported encoding",
      "line_number": 1255,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "write_text",
      "class": "ResilientFileHandler",
      "file": "policy_processor.py",
      "signature": "write_text(cls, content, file_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Write text content with UTF-8 encoding and directory creation.",
      "line_number": 1289,
      "decorators": [
        "classmethod"
      ],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": false
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "PolicyAnalysisPipeline",
      "file": "policy_processor.py",
      "signature": "__init__(self, config, questionnaire_path)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 1310,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "analyze_file",
      "class": "PolicyAnalysisPipeline",
      "file": "policy_processor.py",
      "signature": "analyze_file(self, input_path, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisPipeline must be initialized"
      ],
      "risks": [],
      "docstring": "Execute complete analysis pipeline on a policy document file.\n\nArgs:\n    input_path: Path to input policy document (text format)\n    output_path: Optional path for JSON results export\n\nReturns:\n    Complete analysis results dictionary",
      "line_number": 1340,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": true,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "analyze_text",
      "class": "PolicyAnalysisPipeline",
      "file": "policy_processor.py",
      "signature": "analyze_text(self, raw_text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of PolicyAnalysisPipeline must be initialized"
      ],
      "risks": [],
      "docstring": "Execute analysis pipeline on raw text input.\n\nArgs:\n    raw_text: Raw policy document text\n\nReturns:\n    Complete analysis results dictionary",
      "line_number": 1391,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "BayesianConfidenceCalculator",
      "file": "policy_processor.py",
      "signature": "__init__(self)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 54,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "calculate_posterior",
      "class": "BayesianConfidenceCalculator",
      "file": "policy_processor.py",
      "signature": "calculate_posterior(self, evidence_strength, observations, domain_weight)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of BayesianConfidenceCalculator must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 58,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "verify_temporal_consistency",
      "class": "TemporalLogicVerifier",
      "file": "policy_processor.py",
      "signature": "verify_temporal_consistency(self, statements)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of TemporalLogicVerifier must be initialized"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 68,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "detect",
      "class": "_FallbackContradictionDetector",
      "file": "policy_processor.py",
      "signature": "detect(self, text, plan_name, dimension)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of _FallbackContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 72,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_policy_statements",
      "class": "_FallbackContradictionDetector",
      "file": "policy_processor.py",
      "signature": "_extract_policy_statements(self, text, dimension)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of _FallbackContradictionDetector must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "No documentation available",
      "line_number": 89,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "__init__(self, dimension_descriptions, cluster_weights, cluster_policy_weights, causal_thresholds)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize report assembler with rubric definitions",
      "line_number": 141,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_micro_answer",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "generate_micro_answer(self, question_spec, execution_results, plan_text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate MICRO-level answer for a single question\n\nArgs:\n    question_spec: Question specification with scoring modality\n    execution_results: Dict of adapter execution results\n    plan_text: Original plan document text\n    \nReturns:\n    MicroLevelAnswer with complete analysis",
      "line_number": 200,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_scoring_modality",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_apply_scoring_modality(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Apply scoring modality (TYPE_A, TYPE_B, etc.) to calculate question score\n\nReturns:\n    (score, elements_found, pattern_matches, causal_correction_metadata)",
      "line_number": 307,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_causal_correction",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_apply_causal_correction(self, question_spec, base_score, execution_results)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Adjust base score using causal coherence signals when required.",
      "line_number": 380,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_causal_signals",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_causal_signals(self, execution_results)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Collect numeric causal signals present in execution results.",
      "line_number": 439,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_extract_causal_flags",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_causal_flags(self, execution_results)",
      "complexity": "HIGH",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Identify boolean causal flags signalling structural issues.",
      "line_number": 474,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 90.0
    },
    {
      "method_name": "_score_type_a",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_a(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_A: Binary presence/absence scoring (from rubric_scoring.json)\n\nFORMULA: Score = (elements_found / 4) * 3\n- Expected elements: 4 (as defined in rubric TYPE_A)\n- Each element worth: 0.75 points\n- Max score: 3.0 points\n\nCONVERSION TABLE (from rubric):\n0 elements → 0.00 points\n1 element  → 0.75 points\n2 elements → 1.50 points\n3 elements → 2.25 points\n4 elements → 3.00 points\n\nPRECONDITIONS:\n- question_spec must have expected_elements list\n- execution_results must be non-empty dict\n- plan_text must be non-empty string",
      "line_number": 505,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_type_b",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_b(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_B: Weighted sum of multiple elements\n\nDifferent elements have different weights",
      "line_number": 564,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_type_c",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_c(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_C: Quality assessment with rubric\n\nUses confidence scores from adapters to assess quality",
      "line_number": 602,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_type_d",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_d(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_D: Numerical threshold matching\n\nChecks if numerical values meet specified thresholds",
      "line_number": 631,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_type_e",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_e(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_E: Logical rule-based scoring (from rubric_scoring.json)\n\nApplies if-then-else logic based on custom rules\nUses custom logic defined per question\n\nPRECONDITIONS:\n- question_spec must have validation_rules with logical conditions\n- execution_results must be non-empty dict",
      "line_number": 667,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_type_f",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_type_f(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "TYPE_F: Semantic analysis with similarity matching (from rubric_scoring.json)\n\nUses semantic matching with cosine similarity\nApplies thresholds based on coverage ratio\n\nFORMULA: f(coverage_ratio) with thresholds\n- similarity_threshold: 0.6 (default from rubric)\n\nPRECONDITIONS:\n- question_spec must have expected_elements or search_patterns\n- execution_results must contain semantic analysis results",
      "line_number": 738,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_evaluate_condition",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_evaluate_condition(self, condition, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Evaluate a logical condition for TYPE_E scoring\n\nSupports:\n- \"contains\": check if text contains pattern\n- \"threshold\": check if value meets threshold\n- \"all_of\": all subconditions must be true\n- \"any_of\": at least one subcondition must be true",
      "line_number": 818,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_default",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_default(self, question_spec, execution_results)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Default scoring: Confidence-weighted average",
      "line_number": 882,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_numerical_value",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_numerical_value(self, metric, execution_results)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Extract numerical value for a metric from execution results",
      "line_number": 906,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_pattern_matches",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_pattern_matches(self, question_spec, execution_results, plan_text)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Extract pattern matches from execution results",
      "line_number": 921,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_score_to_qualitative_question",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_score_to_qualitative_question(self, score)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Map quantitative score (0-3) to qualitative level\n\nUses question_rubric thresholds with >= comparisons from high to low.\nThis ensures highest scores are matched first, preventing incorrect\nassignment to lower rubrics.",
      "line_number": 936,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_evidence_excerpts",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_evidence_excerpts(self, question_spec, execution_results, elements_found, plan_text, max_excerpts)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Extract relevant text excerpts as evidence\n\nReturns up to max_excerpts text snippets from plan",
      "line_number": 955,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_find_context_around",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_find_context_around(self, keyword, text, context_chars)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state",
        "NLP libraries",
        "text processing"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Find text excerpt around keyword",
      "line_number": 990,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_confidence",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_confidence(self, execution_results, elements_found, pattern_matches)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate overall confidence score\n\nCombines:\n- Adapter confidence scores\n- Element detection rate\n- Pattern match quality",
      "line_number": 1017,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_explanation",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_generate_explanation(self, question_spec, score, qualitative, elements_found, execution_results, evidence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Generate doctoral-level explanation (150-300 words)\n\nExplains:\n- What was evaluated\n- What was found\n- Why it received this score\n- Implications for policy implementation",
      "line_number": 1053,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_summarize_module_data",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_summarize_module_data(self, result)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Create brief summary of module result data",
      "line_number": 1140,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_meso_cluster",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "generate_meso_cluster(self, cluster_name, cluster_description, micro_answers, cluster_definition)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate MESO-level cluster aggregation\n\nArgs:\n    cluster_name: Cluster identifier (e.g., \"CLUSTER_1\")\n    cluster_description: Human-readable description\n    micro_answers: List of MICRO answers in cluster\n    cluster_definition: Cluster configuration\n    \nReturns:\n    MesoLevelCluster with aggregated analysis",
      "line_number": 1155,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_dimension_scores",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_dimension_scores(self, micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate average scores by dimension (as percentages)",
      "line_number": 1269,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_policy_area_scores",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_policy_area_scores(self, micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate average scores per policy area in percentage scale.",
      "line_number": 1288,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_policy_weighting",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_apply_policy_weighting(self, cluster_id, fallback_score, policy_area_scores, cluster_definition)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Apply rubric-defined weights to policy area contributions.",
      "line_number": 1308,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_coefficient_of_variation",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_coefficient_of_variation(self, scores)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate coefficient of variation for dispersion-aware scoring.",
      "line_number": 1345,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_dispersion",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_classify_dispersion(self, cv, sample_size)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Classify dispersion profile using coefficient of variation.",
      "line_number": 1357,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_dispersion_adjustment",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_apply_dispersion_adjustment(self, base_confidence, cv)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Adjust cluster confidence based on dispersion.",
      "line_number": 1368,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_summarize_probative_tests",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_summarize_probative_tests(self, answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Aggregate probative taxonomy distribution across answers.",
      "line_number": 1377,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_dimension_coverage_index",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_dimension_coverage_index(self, all_micro_answers, plan_metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate coverage ratios per dimension for gating.",
      "line_number": 1397,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_validate_macro_gating",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_validate_macro_gating(self, all_micro_answers, coverage_index)",
      "complexity": "LOW",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Validate macro gating constraints (coverage + causal integrity).",
      "line_number": 1424,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_strengths",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_identify_strengths(self, micro_answers, dimension_scores)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Identify cluster strengths",
      "line_number": 1467,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_weaknesses",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_identify_weaknesses(self, micro_answers, dimension_scores)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Identify cluster weaknesses",
      "line_number": 1509,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_cluster_recommendations",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_generate_cluster_recommendations(self, cluster_name, micro_answers, strengths, weaknesses)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate strategic recommendations for cluster",
      "line_number": 1553,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_assess_evidence_quality",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_assess_evidence_quality(self, micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Assess overall evidence quality",
      "line_number": 1604,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_score_distribution",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_score_distribution(self, micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate distribution of qualitative scores",
      "line_number": 1621,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "generate_macro_convergence",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "generate_macro_convergence(self, all_micro_answers, all_meso_clusters, plan_metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate MACRO-level convergence analysis\n\nArgs:\n    all_micro_answers: All MICRO answers across all questions\n    all_meso_clusters: All MESO clusters\n    plan_metadata: Plan document metadata\n    \nReturns:\n    MacroLevelConvergence with executive summary",
      "line_number": 1635,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_aggregate_macro_score",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_aggregate_macro_score(self, meso_clusters, fallback_score)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Aggregate macro score using rubric-defined cluster weights.",
      "line_number": 1760,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_dimension_convergence",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_dimension_convergence(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate convergence score by dimension (percentages)",
      "line_number": 1814,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_policy_area_convergence",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_policy_area_convergence(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate convergence score by policy area (percentages)",
      "line_number": 1832,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_perform_gap_analysis",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_perform_gap_analysis(self, all_micro_answers, dim_convergence, policy_convergence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Perform comprehensive gap analysis",
      "line_number": 1850,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_agenda_alignment",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_agenda_alignment(self, all_micro_answers, plan_metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate alignment with Decálogo agenda (0.0-1.0)\n\nBased on:\n- Coverage of all dimensions\n- Quality of evidence\n- Overall confidence",
      "line_number": 1907,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_identify_critical_gaps",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_identify_critical_gaps(self, gap_analysis, dim_convergence)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Identify the most critical gaps requiring attention",
      "line_number": 1945,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_strategic_recommendations",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_generate_strategic_recommendations(self, overall_score, dim_convergence, critical_gaps, meso_clusters)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate executive-level strategic recommendations",
      "line_number": 1977,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_classify_plan",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_classify_plan(self, overall_score)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Classify plan using rubric levels (percentage scale 0-100)\n\nUses >= comparisons from high to low to ensure correct assignment.",
      "line_number": 2038,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_synthesize_evidence",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_synthesize_evidence(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Synthesize evidence across all questions",
      "line_number": 2056,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_generate_implementation_roadmap",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_generate_implementation_roadmap(self, critical_gaps, strategic_recommendations)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Generate prioritized implementation roadmap",
      "line_number": 2078,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_overall_distribution",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_overall_distribution(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate overall score distribution",
      "line_number": 2117,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_confidence_metrics",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_confidence_metrics(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate confidence metrics",
      "line_number": 2127,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_apply_macro_prompts",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_apply_macro_prompts(self, all_micro_answers, all_meso_clusters, convergence_by_dimension, convergence_by_policy_area, missing_clusters, critical_gaps, confidence_metrics, plan_metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [
        "Multiple parameters increase error surface"
      ],
      "docstring": "Apply all 5 macro-level analysis prompts\n\nReturns enriched analysis including:\n- Coverage gap assessment\n- Inter-level contradiction detection\n- Bayesian portfolio composition\n- Optimized implementation roadmap\n- Peer-normalized confidence",
      "line_number": 2141,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_dimension_coverage",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_dimension_coverage(self, all_micro_answers, plan_metadata)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate coverage percentage by dimension\n\nCoverage is calculated as: answered_questions / expected_questions_for_dimension\nIf dimension_expected_counts is not provided in plan_metadata, falls back to\ncalculating based on the questions present in all_micro_answers.",
      "line_number": 2231,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_calculate_policy_area_coverage",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_calculate_policy_area_coverage(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Calculate coverage percentage by policy area",
      "line_number": 2286,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_micro_claims",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_micro_claims(self, all_micro_answers)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Extract micro-level claims from answers",
      "line_number": 2309,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_extract_meso_signals",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_extract_meso_signals(self, all_meso_clusters)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Extract meso-level summary signals",
      "line_number": 2328,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_structure_critical_gaps",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_structure_critical_gaps(self, critical_gaps)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Structure critical gaps with effort and impact estimates",
      "line_number": 2340,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "_get_peer_distributions",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "_get_peer_distributions(self, convergence_by_policy_area)",
      "complexity": "LOW",
      "priority": "LOW",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Get peer distributions for normalization (mock data)",
      "line_number": 2366,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_report",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "export_report(self, micro_answers, meso_clusters, macro_convergence, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Export complete report to JSON\n\nArgs:\n    micro_answers: All MICRO-level answers\n    meso_clusters: All MESO-level clusters\n    macro_convergence: MACRO-level convergence\n    output_path: Path to save JSON report",
      "line_number": 2386,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_micro_answer_schema",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "validate_micro_answer_schema(self, answer_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MICRO answer against JSON schema",
      "line_number": 2425,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_meso_cluster_schema",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "validate_meso_cluster_schema(self, cluster_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MESO cluster against JSON schema",
      "line_number": 2443,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_macro_convergence_schema",
      "class": "ReportAssembler",
      "file": "report_assembly.py",
      "signature": "validate_macro_convergence_schema(self, convergence_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssembler must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MACRO convergence against JSON schema",
      "line_number": 2461,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "__init__",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "__init__(self, dimension_descriptions, cluster_weights, cluster_policy_weights, causal_thresholds)",
      "complexity": "MEDIUM",
      "priority": "CRITICAL",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [],
      "risks": [],
      "docstring": "Initialize producer with optional configuration",
      "line_number": 2495,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "produce_micro_answer",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "produce_micro_answer(self, question_spec, execution_results, plan_text)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Produce MICRO-level answer for a single question\n\nReturns: Serializable dictionary with complete answer",
      "line_number": 2515,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_score",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_score(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract quantitative score from MICRO answer",
      "line_number": 2531,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_qualitative",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_qualitative(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract qualitative classification from MICRO answer",
      "line_number": 2535,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_evidence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_evidence(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract evidence excerpts from MICRO answer",
      "line_number": 2539,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_confidence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_confidence(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract confidence score from MICRO answer",
      "line_number": 2543,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_modules",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_modules(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract list of executed modules from MICRO answer",
      "line_number": 2547,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_execution_time",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_execution_time(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract execution time from MICRO answer",
      "line_number": 2551,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_micro_answer_elements_found",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_micro_answer_elements_found(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract detected elements from MICRO answer",
      "line_number": 2555,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "count_micro_evidence_excerpts",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "count_micro_evidence_excerpts(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Count evidence excerpts in MICRO answer",
      "line_number": 2559,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_micro_answer_excellent",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_micro_answer_excellent(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MICRO answer is classified as EXCELENTE",
      "line_number": 2563,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_micro_answer_passing",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_micro_answer_passing(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MICRO answer meets minimum passing threshold",
      "line_number": 2567,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "produce_meso_cluster",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "produce_meso_cluster(self, cluster_name, cluster_description, micro_answers, cluster_definition)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Produce MESO-level cluster aggregation\n\nReturns: Serializable dictionary with cluster analysis",
      "line_number": 2575,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_score",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_score(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract average score from MESO cluster",
      "line_number": 2597,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_policy_areas",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_policy_areas(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract policy areas from MESO cluster",
      "line_number": 2601,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_dimension_scores",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_dimension_scores(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract dimension scores from MESO cluster",
      "line_number": 2605,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_strengths",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_strengths(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract identified strengths from MESO cluster",
      "line_number": 2609,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_weaknesses",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_weaknesses(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract identified weaknesses from MESO cluster",
      "line_number": 2613,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_recommendations",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_recommendations(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract recommendations from MESO cluster",
      "line_number": 2617,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_coverage",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_coverage(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract question coverage percentage from MESO cluster",
      "line_number": 2621,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_meso_cluster_question_counts",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_meso_cluster_question_counts(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract total and answered question counts from MESO cluster",
      "line_number": 2625,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "count_meso_strengths",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "count_meso_strengths(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Count strengths identified in MESO cluster",
      "line_number": 2629,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "count_meso_weaknesses",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "count_meso_weaknesses(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Count weaknesses identified in MESO cluster",
      "line_number": 2633,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_meso_cluster_excellent",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_meso_cluster_excellent(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MESO cluster score is in EXCELENTE range",
      "line_number": 2637,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_meso_cluster_passing",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_meso_cluster_passing(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MESO cluster meets minimum passing threshold",
      "line_number": 2641,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "produce_macro_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "produce_macro_convergence(self, all_micro_answers, all_meso_clusters, plan_metadata)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Produce MACRO-level convergence analysis\n\nReturns: Serializable dictionary with executive summary",
      "line_number": 2649,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_overall_score",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_overall_score(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract overall score from MACRO convergence",
      "line_number": 2673,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_dimension_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_dimension_convergence(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract dimension convergence scores from MACRO",
      "line_number": 2677,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_policy_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_policy_convergence(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract policy area convergence scores from MACRO",
      "line_number": 2681,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_gap_analysis",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_gap_analysis(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract gap analysis from MACRO convergence",
      "line_number": 2685,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_agenda_alignment",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_agenda_alignment(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract agenda alignment score from MACRO",
      "line_number": 2689,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_critical_gaps",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_critical_gaps(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract critical gaps list from MACRO",
      "line_number": 2693,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_strategic_recommendations",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_strategic_recommendations(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract strategic recommendations from MACRO",
      "line_number": 2697,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_classification",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_classification(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract plan classification from MACRO",
      "line_number": 2701,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_evidence_synthesis",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_evidence_synthesis(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract evidence synthesis from MACRO",
      "line_number": 2705,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_implementation_roadmap",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_implementation_roadmap(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract implementation roadmap from MACRO",
      "line_number": 2709,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_score_distribution",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_score_distribution(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract score distribution from MACRO",
      "line_number": 2713,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_macro_confidence_metrics",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_macro_confidence_metrics(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Extract confidence metrics from MACRO",
      "line_number": 2717,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "count_macro_critical_gaps",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "count_macro_critical_gaps(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Count critical gaps in MACRO convergence",
      "line_number": 2721,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "count_macro_strategic_recommendations",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "count_macro_strategic_recommendations(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Count strategic recommendations in MACRO",
      "line_number": 2725,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_macro_excellent",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_macro_excellent(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MACRO overall score is in EXCELENTE range",
      "line_number": 2729,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "is_macro_passing",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "is_macro_passing(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Check if MACRO meets minimum passing threshold",
      "line_number": 2733,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "convert_score_to_percentage",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "convert_score_to_percentage(self, score)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Convert 0-3 score to 0-100 percentage",
      "line_number": 2741,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "convert_percentage_to_score",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "convert_percentage_to_score(self, percentage)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Convert 0-100 percentage to 0-3 score",
      "line_number": 2745,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "classify_score",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "classify_score(self, score)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify a 0-3 score into qualitative level",
      "line_number": 2749,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "classify_percentage",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "classify_percentage(self, percentage)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Classify a 0-100 percentage into qualitative level",
      "line_number": 2753,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_rubric_threshold",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_rubric_threshold(self, level)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get percentage threshold range for a rubric level",
      "line_number": 2760,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_question_rubric_threshold",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_question_rubric_threshold(self, level)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get 0-3 score threshold range for question-level rubric",
      "line_number": 2764,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_dimension_description",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_dimension_description(self, dimension)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get description for a dimension (D1-D6)",
      "line_number": 2772,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "list_dimensions",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "list_dimensions(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "List all dimensions",
      "line_number": 2776,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "list_rubric_levels",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "list_rubric_levels(self)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "List all rubric levels",
      "line_number": 2780,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_causal_threshold",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_causal_threshold(self, dimension)",
      "complexity": "HIGH",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [
        "High computational complexity"
      ],
      "docstring": "Get causal coherence threshold for a dimension",
      "line_number": 2784,
      "decorators": [],
      "execution_requirements": {
        "computational": "HIGH",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 85.0
    },
    {
      "method_name": "get_cluster_weight",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_cluster_weight(self, cluster_id)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get weight for a cluster in macro aggregation",
      "line_number": 2791,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "get_cluster_policy_weights",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "get_cluster_policy_weights(self, cluster_id)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Get policy area weights for a cluster",
      "line_number": 2795,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "export_complete_report",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "export_complete_report(self, micro_answers, meso_clusters, macro_convergence, output_path)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Export complete report to JSON file",
      "line_number": 2803,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "serialize_micro_answer",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "serialize_micro_answer(self, answer)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Serialize MICRO answer to dictionary",
      "line_number": 2823,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "serialize_meso_cluster",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "serialize_meso_cluster(self, cluster)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Serialize MESO cluster to dictionary",
      "line_number": 2827,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "serialize_macro_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "serialize_macro_convergence(self, convergence)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Serialize MACRO convergence to dictionary",
      "line_number": 2831,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "deserialize_micro_answer",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "deserialize_micro_answer(self, data)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Deserialize dictionary to MICRO answer",
      "line_number": 2835,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "deserialize_meso_cluster",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "deserialize_meso_cluster(self, data)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Deserialize dictionary to MESO cluster",
      "line_number": 2839,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "deserialize_macro_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "deserialize_macro_convergence(self, data)",
      "complexity": "MEDIUM",
      "priority": "MEDIUM",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized",
        "Input data must be validated and properly formatted"
      ],
      "risks": [],
      "docstring": "Deserialize dictionary to MACRO convergence",
      "line_number": 2843,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_micro_answer",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "validate_micro_answer(self, answer_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MICRO answer against JSON schema",
      "line_number": 2851,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_meso_cluster",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "validate_meso_cluster(self, cluster_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MESO cluster against JSON schema",
      "line_number": 2855,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    },
    {
      "method_name": "validate_macro_convergence",
      "class": "ReportAssemblyProducer",
      "file": "report_assembly.py",
      "signature": "validate_macro_convergence(self, convergence_data)",
      "complexity": "MEDIUM",
      "priority": "HIGH",
      "dependencies": [
        "Instance state"
      ],
      "prerequisites": [
        "Instance of ReportAssemblyProducer must be initialized"
      ],
      "risks": [],
      "docstring": "Validate MACRO convergence against JSON schema",
      "line_number": 2859,
      "decorators": [],
      "execution_requirements": {
        "computational": "MEDIUM",
        "memory": "MEDIUM",
        "io_bound": false,
        "stateful": true
      },
      "aptitude_score": 100
    }
  ]
}